var documenterSearchIndex = {"docs":
[{"location":"time_interface/#Time-Interaface","page":"Time Interface","title":"Time Interaface","text":"","category":"section"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"To be honest, the time interface for Fable.jl is under construction and not quite ready for general use; however, as an animation engine, it does allow users to use some form of \"time\" component for each FableUserMethod.","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"The most important thing to note is that Fable.jl fundamentally animates per frame, not based on real time! This simply means that the variable sent to each FableUserMethod is not time, but the current frame.","category":"page"},{"location":"time_interface/#How-to-use-the-Fable.jl-time-interface","page":"Time Interface","title":"How to use the Fable.jl time interface","text":"","category":"section"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"Right now, simply create a FableUserMethod that uses the frame variable, and then pass some time argument along to your run!(...) function as a keyword argument:","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"run!(layer; time = t)","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"Here t could be a Float that represents the number of seconds, an Int that represents the current frame, or a Unitful quantity (like `1u\"s\") which represents some other unit of time.","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"I'll be adding more to these docs as the time interface becomes more stable, but for now, please feel free to let me know what you think on the relevant issue!","category":"page"},{"location":"postprocessing/#Post-processing","page":"Post Processing","title":"Post processing","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Once you have generated an image via any of the provided Fable Executables (such as Colors, Shaders, or Hutchinson operators), you may want to do additional operations before writing to file. Right now, we support the following operations:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Clipping: This is the process of turning any pixel above a given threshold intensity into another desired color.\nFiltering: This is essentially a convolution with a provided filter, for effects like a Gaussian blur.\nSobel: This is a Sobel filter (without directional information). It is useful for edge detection or simple outlines.\nOutlines: This takes the Sobel information and turns it into a more distinct outline.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"In this discussion, I will also describe how you may write your own post processing option, if you want. All the examples can be found in examples/postprocessing.md.","category":"page"},{"location":"postprocessing/#General-Notes","page":"Post Processing","title":"General Notes","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The postprocess!(...) function is called when using write_image(...) or write_video(...). This means that the post processing step happens after the all FableExecutables have been run(...). Importantly, all post processing steps act exclusively on the canvas for each AbstractLayer type. Each canvas is essentially an Array (CuArray or ROCArray) of RGBA values that are initialized before post processing occurs. Each post processing step is performed in the order they are added to the postprocessing_steps Vector in each AbstractLayer.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"There is no default post process for Shader and Color layers, which essentially means that no post process will be performed unless specified by the user. For FableLayers, there is always a CopyToCanvas(...) post process, which essentially takes the RGBA information from the run(...) function and turns it into a canvas for later post processing steps. In practice, this is a small discrepancy that users should not need to worry about.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"For the following examples, we will be performing post processing on a simple circle created via a FableExecutable:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function quick_circle(num_particles, num_iterations; ArrayType = Array,\n                      filename = \"out.png\")\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType)\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will create a pink circle that looks like this:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A simple circle)","category":"page"},{"location":"postprocessing/#Clipping","page":"Post Processing","title":"Clipping","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"By default, the Clip post process will turn any RGBA value above a pre-defined threshold to another designated color; however, you can change the clip_op(clip operator) to use any function instead of >. You may also change how the intensity is calculated by passing in an intensity_function argument. Fable.jl currently supports the following intensity functions:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"@inline function simple_intensity(c::CT) where CT <: Union{RGB}\n   return (c.r/3) + (c.g/3) + (c.b/3)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"and","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"@inline function perceptive_intensity(c::CT) where CT <: Union{RGBA}\n    return c.alpha * ((0.21 * c.r) + (0.72 * c.g) + (0.07 * c.b))\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The latter is meant to more realistically portray to how humans perceive light.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Clip post process can be created like so:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"clip = Clip(; threshold = 0.5, color = RGBA(0,0,0,1),\n              intensity_function = simple_intensity, clip_op = >)","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Note that the key word arguments above are also the defaults for the Clip post process. Here is a quick example:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function clip_example(num_particles, num_iterations; ArrayType = Array,\n                      filename = \"clip_out.png\")\n\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    clip = Clip(; threshold = 0.5, color = RGBA(1, 1, 0, 1))\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [clip])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will turn our pink ball yellow:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A yellow circle)","category":"page"},{"location":"postprocessing/#Filtering","page":"Post Processing","title":"Filtering","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Filter post process essentially performs a convolution with a provided filter. Convolutions are somewhat complicated to understand, but if you want to learn more, please check out the chapter(s) available on the Algorithm Archive. All the necessary information for understanding how this post process works can be found there, along with an example using the Sobel operator.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"By default, Fable.jl provides the following filters:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Identity: This is a test filter and just returns the exact image back","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function Identity(; filter_size = 3, ArrayType = Array)\n    if iseven(filter_size)\n        filter_size = filter_size - 1\n        @warn(\"filter sizes must be odd! New filter size is \" *\n              string(filter_size)*\"!\")\n    end\n    filter = zeros(filter_size, filter_size)\n    idx = ceil(Int, filter_size*0.5)\n    filter[idx, idx] = 1\n\n    return Filter(filter!, ArrayType(filter), nothing, false)\nend\n","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Gaussian / Blur: these perform a Gaussian blur of the image.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function gaussian(x,y, sigma)\n    return (1/(2*pi*sigma*sigma))*exp(-((x*x + y*y)/(2*sigma*sigma)))\nend\n\nfunction Blur(; filter_size = 3, ArrayType = Array, sigma = 1.0)\n    return Gaussian(; filter_size = filter_size, ArrayType = ArrayType,\n                      sigma = sigma)\nend\n\nfunction Gaussian(; filter_size = 3, ArrayType = Array, sigma = 1.0)\n    if iseven(filter_size)\n        filter_size = filter_size - 1\n        @warn(\"filter sizes must be odd! New filter size is \" *\n              string(filter_size)*\"!\")\n    end\n    if filter_size > 1\n        filter = zeros(filter_size, filter_size)\n        for i = 1:filter_size\n            y = -1 + 2*(i-1)/(filter_size-1) \n            for j = 1:filter_size\n                x = -1 + 2*(j-1)/(filter_size-1) \n                filter[i,j] = gaussian(x, y, sigma)\n            end\n        end\n    else\n        filter = [1.0]\n    end\n\n    filter ./= sum(filter)\n    return Filter(filter!, ArrayType(filter), nothing, false)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Sobel post process also uses a Filter, but it will be discussed separately in the next section.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The only important note here is that because users are creating kernels themselves, it is possible to accidentally create a kernel of a different ArrayType than the layer's canvas. In this case, the kernel will change the array type of the filter and provide the following warning:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Info: filter array type not the same as canvas!\nConverting filter to canvas type...","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Finally, here is a quick example using the Gaussian Blur post process (note you can also use the same post process by calling Gaussian instead in the same way):","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function blur_example(num_particles, num_iterations; ArrayType = Array,\n                      filter_size = 3, filename = \"blur_out.png\")\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    blur = Blur(; filter_size = filter_size)\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [blur])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will produce the following image when using a 100times 100 filter:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A blurred circle)","category":"page"},{"location":"postprocessing/#Sobel-operator","page":"Post Processing","title":"Sobel operator","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Sobel operator is often called an \"image derivative.\" More information can be found on the Algorithm Archive. In general, this operation can be split into 3 steps:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"A gradient in the x direction (G_x)\nA gradient in the y direction (G_y)\nA sum of both gradients: sqrtG_x^2 + G_y^2","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"As an important note, many implementations of the Sobel operator also return gradient direction information. This part of the operation is not performed in Fable.jl by default.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here is a quick example using the Sobel operator:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function sobel_example(num_particles, num_iterations; ArrayType = Array,\n                       filename = \"sobel_out.png\")\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    sobel = Sobel()\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [sobel])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will produce the following image:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A sobel circle)","category":"page"},{"location":"postprocessing/#Outlines","page":"Post Processing","title":"Outlines","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Outlines are surprisingly tricky to get right. I will not argue that the Outline implementation in Fable.jl is perfect, but it works well enough for now.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The current implementation was inspired by Canny edge detection and does the following:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Blurs the given image by some factor related to the user-provided linewidth variable.\nPerforms a Sobel operation on the image to get the image derivative.\nPerforms naive ridge detection, which sets any value in the Sobel-operated canvas above a certain threshold to be the provided outline color. This is essentially a Clip post process from above.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"There are a bunch of key word arguments you can use for Outline:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"outline = Outline(; linewidth = 1,\n                   color = RGBA(1.0, 1.0, 1.0, 1.0),\n                   intensity_function = simple_intensity,\n                   object_outline = false,\n                   threshold = 1/(linewidth*linewidth+1),\n                   sigma = 1)\n","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here, linewidth is the desired line width of the outline, color is the desired color, intensity_function is the intensity function as described in the Clip subsection above, threshold is used for ridge detection, and sigma defines the width of the Gaussian for the blur kernel. The only tricky argument is object_outline, which is specifically for FableLayers. It indicates that the user wants to outline the fractal object, itself, not any inner components from potentially using a FableUserMethod for coloring the fractal object.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here is a quick example using the Outline post process:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function outline_example(num_particles, num_iterations; ArrayType = Array,\n                         filename = \"outline_out.png\", linewidth = 1,\n                         object_outline = false)\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    outline = Outline(; linewidth = linewidth, object_outline = object_outline)\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [outline])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will produce the following image:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: An outlined circle)","category":"page"},{"location":"postprocessing/#Building-your-own","page":"Post Processing","title":"Building your own","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Finally, we will touch on what is necessary to build a post process from scratch. Right now, this can be done by creating a new AbstractPostProcess struct, similar to those used in the above examples. Here is the Clip post processing struct for reference:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"struct Clip <: AbstractPostProcess\n    op::Function\n    clip_op::Function\n    intensity_function::Function\n    threshold::Number\n    color::CT where CT <: Union{RGB, RGBA}\n    initialized::Bool\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"To be honest, this part of the code is a little sticky right now, so feel free to try to clean it up in a PR, but the minimal AbstractPostProcess struct would look like this:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"struct Minimal <: AbstractPostProcess\n    op::Function\n    initialized::Bool\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here, op is the provided function the AbstractPostProcess should use, while initialized is a boolean value indicating whether the post process needs initialization. This is useful for post processes that require additional canvas parameters, like the Filter post process:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"mutable struct Filter <: AbstractPostProcess\n    op::Function\n    filter::AT where AT <: Union{Array, CuArray, ROCArray}\n    canvas::AT where AT <: Union{Array, CuArray, ROCArray, Nothing}\n    initialized::Bool\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"If initialized is set to false, the initialize!(...) function will be called when using the post process for the first time. Here is the initialize!(...) function for Filter:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function initialize!(filter::Filter, layer::AL) where AL <: AbstractLayer\n    ArrayType = layer.params.ArrayType\n    if !(typeof(filter.filter) <: layer.params.ArrayType)\n        @info(\"filter array type not the same as canvas!\\nConverting filter to canvas type...\")\n        filter.filter = ArrayType(filter.filter)\n    end\n    filter.canvas = ArrayType(zeros(eltype(layer.canvas), size(layer.canvas)))\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Note that all initialize! functions should have the args (filter::Filter, layer::AL). In practice, these functions are usually used to make sure that the post process canvas has the same ArrayType and size as the layer.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"As a final note: when designing an op function to be used for each post process, remember that the ArrayType could be a CuArray or ROCArray, so try to make the functions GPU friendly. This is why many of the post processes are written in KernelAbstractions.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Again, this part of the code is sticky, so if you need to add another post process, feel free to create an issue and we can talk about whether it makes sense to add directly to Fable.jl!","category":"page"},{"location":"death/#The-Future-of-Fable(.jl)","page":"This Package Is Dead","title":"The Future of Fable(.jl)","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Long story short: Fable(.jl) will no longer be developed by me at this point in time. I have moved on to a new project, quibble.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Let's talk about that in detail.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"This rendering engine has taken many forms:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"FFlamify.jl was an attempt to do fast fractal flame rendering in Julia. It worked, but it wasn't fast.\nFae.jl was a Fractal Animation Engine that used the FFlamify idea and then extended it to general purpose rendering.\nFable.jl was / is the final incarnation of that idea in Julia. It took years of full time work and I was never really happy with it.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"A few weeks ago, I took an afternoon to rewrite the heart of the code in OpenCL C. I got it working and it was lightning fast. To reiterate: I got it to work in an afternoon in C. I have been struggling to get this engine to work in Julia for years. In a sense, that was \"the final nail in the coffin\" for me. Now, I'm old and bitter and can't help but feel I flushed two years of full time effort down the drain.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"That said, I do wholeheartedly believe that Julia has the best GPGPU ecosystem in the business. It's just that for this specific project, I cannot use Julia. Rather, I can. There's a possibility that SPIRV(.jl) and Vulkan(.jl) can save me here. Or maybe the GPUCompiler gets a speed up like what just happened in Julia 1.10. Or maybe I'm just an idiot and there's a clever way around my problems that I just haven't thought of yet. For now, I really need a break from the language. ","category":"page"},{"location":"death/#So-what's-the-problem?","page":"This Package Is Dead","title":"So what's the problem?","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Fable is a general-purpose rendering engine that does away with the traditional mesh machinery from OpenGL and Vulkan. It's all function systems. You can read more about it here in the docs if you are interested.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"To be honest, it works. The runtime is super fast. Like 5000+ frames per second fast (and that's for a relatively unoptimized approach). The problem is that the user-generated functions need to be compiled somewhere and compilation (in Julia) can take minutes of time. The reason I recently switched to C is that the same compilation process can be done in OpenCL in milliseconds.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So why? Why is Julia uniquely bad here? Why is this so hard?","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Well, it's not just a Julia issue. It's also a GPU one.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"See, function pointers aren't really properly sussed out in GPU code. You can technically use them in CUDA with restrictions and in OpenCL 2.1, but OpenCL 1, OpenCL 3, Vulkan, OpenGL, and pretty much every other GPU library forbids them (for good reason). GPUs are quite different than CPUs. Memory is limited. Threads are weak. Function call graphs, though not incredibly hefty, are hefty enough to be avoided for thread-wise execution.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"On the other hand, GPU programming is hard, and most people are not working alone. If there's only one GPU programmer and several other lab mates all wanting to use their GPU code, then it makes sense to allow for some flexibility. For that reason, even though function pointers are not straightforward, it's incredibly common for GPU programmers to simulate them in other ways. Let's discuss how:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"The CUDA Approach: As mentioned earlier, CUDA actually does allow for function pointers on the GPU. The problem is that they are limited only to functions compiled in the same CuModule. This effectively means there are two options for simulating general function pointers on CUDA-capable devices:\nMess around with the compilation of the code, itself, to make sure that the appropriate functions are in the same CuModule. This is common enough that there are actually CMake commands to do this.\nSend the functions in to your kernel as an Abstract Syntax Tree (or expression tree if you are lucky) and parse that on the GPU. To do this, you just need to make sure that all the functions necessary for parsing the user-provided code are in the same module.\nThe OpenCL Approach: This approach is way, way easier. Because OpenCL (and OpenGL / Vulkan) separate out the compilation of kernels (or shaders), all you need to do to simulate function pointers is throw user code directly into the string that eventually turns into a kernel. For this reason, I often say that \"OpenCL has the best metaprogramming of any language I've ever used.\" It's just so easy to work with.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"I have personally implemented all of these approaches (CUDA 1 & 2, OpenCL, and GLSL / OpenGL) before during my PhD. It took maybe a month to do everything in CUDA and a few days to do it in OpenCL. Since then, I have had to solve this problem time and time again in a variety of different ways. It always comes up. It's so common that I have often made the claim that \"In 202X, languages are defined by their ability to metaprogram GPU code. That is literally the only problem that matters.\" It was also the core reason I began exploring non-CUDA options for GPU programming.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So now let's talk Julia. I've been using the language for some time. I'm a member of the Julia Lab at MIT. I am a developer of the JuliaGPU ecosystem.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"If anyone was going to get this to work in Julia, it would be me. Or so I thought. But then came the time to actually write the code.","category":"page"},{"location":"death/#Attempt-1:-The-OpenCL-approach","page":"This Package Is Dead","title":"Attempt 1: The OpenCL approach","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"The first thing I tried was generating a giant function string and compiling that into a function with Meta.parse(...) and eval. Should I have used Exprs directly instead of strings? Yeah, probably, but string manipulation was easier and I was looking for a proof of concept at the time. So I did what I could and got the code to work. The problem was that it was super slow to compile.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"At this point, I had already sunk months into development, so I thought, \"No problem! I'll fix it in post!\" I then proceeded to package things up and get it ready for the Julia Registries. Just one small problem.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"As I started to encapsulate everything into a more usable API, I found that it was really difficult to use evaled code in other functions. The problem is that Julia's compiler does not allow for users to call code that was compiled at a later time (in a different world). Up until this point, I had been doing most of my development in the REPL, so I had somehow completely avoided this issue.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Now, there is a solution: Base.@invokelatest. This function will force a function written at an older time to accept a newer function, but it comes at a small cost. At the time, I thought that my compile times were already too long and I was not willing to spend another half-second at this step, so I looked for other options. Also, due to a bug in AMDGPU,jl (which has since been fixed), my entire system was crashing quite regularly and at random due to this codebase, so I needed to change up the tooling.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So let's talk about the \"Julia way.\"","category":"page"},{"location":"death/#Attempt-2:-Macros,-macros,-and-more-macros.","page":"This Package Is Dead","title":"Attempt 2: Macros, macros, and more macros.","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"In Julia, macros are powerful.  They can do just about anything you want to do with Exprs So I thought this would be the perfect solution to my problem. But let's define that problem in more detail.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"There are essentially 4 levels of metaprogramming:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"The variable scope. To avoid recompilation, it's important to tag certain variables as \"dynamic\" (stuff that could change during the runtime). For example, if you have a point that needs to move around in space, the actual location of that point might be a variable input value. These values are essentially stored in a large buffer to be sent in to the GPU at the last minute.\nThe user function stage. This is where users write their own functions to manipulate their point clouds. It's equivalent to vertex and fragment shading in OpenGL and essentially moves and colors individual points.\nThe generator stage. This is where the user's functions all get stitched together into a larger function, along with a generator for the initial primitive (squares, circles, etc) before transformation.\nThe executable stage. Here, multiple objects are all bound to the same layer and all the extra GPU junk is tacked on.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"I suppose these stages could be simplified, but I found them to be the easiest to reason about. The problem is that implementing this pipeline exclusively with macros is difficult because they only accept expressions. If you do:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"expr = @macro_1 stuff\n@macro_2 expr","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"@macro_2 will not see the components of the variable expr, but the single symbol :expr, itself, which is essentially useless.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So what do you do? You macro some stuff, and @generate others. @generated functions are special functions that generate function bodies based on the type information of the arguments. Let me pause here.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Remember how I just tried the OpenCL approach in Julia and it worked? What was I doing there? I was generating a large function body with my own tooling. What am I doing with the macro approach? The same thing! I am now just using less flexible tooling that is bound by weird restrictions that Julia decides to impose on me. But, macros are probably much more safe than whatever I was doing before, so it's best to use them when possible.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"This approach involved passing all the functions in as a Tuple (of mixed type because functions are all designated to have their own type in Julia). I will say that the final code was very, very unique and the closest thing to \"real\" function pointers I've seen on the GPU. The only issue was that I could not iterate through the Tuple of functions due to an issue that I still don't know whether it counts as a \"bug\" or \"oversight\". No matter the case, considering I was literally trying to solve iterated function systems, this was a huge problem. So I needed to @generate a function that would call my specific function from the Tuple with a fixed index (1 instead of i). This meant that if I passed in 100 functions, I would @generate a 100 if statement block and would call that function any time I wanted to call fxs[i].","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Throughout this process, I needed constant help. I didn't know how to @generate the right functions. I couldn't figure out how to configure the functions with the right key word arguments. I ran into an LLVM bug that (let's face it) would have been impossible for me to solve without someone else.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"At the end of the day, my code felt... bad. I can't really describe it.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Never in my life have I copied code from someone else. Sure, there's sometimes the odd bit of boilerplate that I yoink and twist from StackOverflow, but it's never more than a few odd lines here and there.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"When I was done with this version of the code, it didn't feel like mine. The macros were all basically designed by a friend. It was prone to breaking at any point in time without me understanding why. There was one, specific bug that would send me straight into a panic because it always took a full month to solve and I had hit it almost 10 times before (literally 10 months wasted).","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Regardless, the code worked. Just like before.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"This time I did some testing and was quite pleased with the runtime results. However, compile time was abysmal. For a simple system, I was averaging 70 seconds to compile a kernel that would run in 0.0001 s. As much as I tried to avoid recompilation, it's hard to do when you need to dynamically generate a new scene for testing each frame.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"This meant that I was spending literal hours out of my day just waiting for Julia to finish compiling.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So I reached out to the GPU channel on slack (instead of the Julia Lab folks) and asked for help, only to receive a relatively unhelpful set of answers. I understand that that was entirely my fault. I had asked so many people for help with this project, that I had failed to adequately document my issues on github because I thought they were \"well known.\" More than that, I had solved this exact problem so many times in my career, I really don't think it is possible to find someone who is more specialized at solving it.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So I (finally) created the issues and kept at it.","category":"page"},{"location":"death/#Attempt-3-and-performance-tests.","page":"This Package Is Dead","title":"Attempt 3 and performance tests.","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"At this point, I was frazzled beyond belief and felt like I had just been majorly gaslighted on slack. I had solved this very problem multiple times before. In CUDA. In OpenCL. In Julia even. This was possible. It should be fast to compile.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So I went back to the first strategy, but used Exprs this time. And you know what? It was faster than the @generated approach. By a lot.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"But I decided to take it one step further and actually implement the same functionality in OpenCL. I did it in an afternoon after years of leaving my C skills to collect dust. The fact that I could do it in an afternoon already speaks volumes:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"I am not insane. This is actually a fairly trivial thing to do (as long as you know what to do).\nOpenCL's actually great. I'm a big fan.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So let's put some rough numbers down. The compile time for composing 2000 (super simple) functions:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"With Base.Cartesian.@nif: 26 seconds\nWith evaluating a set of exprs: 10 seconds\nWith OpenCL C: negligible. ~100ms for everything.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Note that @nif cannot do much larger without erroring, but methods 2 and 3 can keep going. OpenCL even starts to sweat at 200,000 functions (4 seconds overall time).","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"The runtimes for all these cases are negligible (something like 0.001 s). Also: all the code is at the end.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Now you might be asking, \"Ok. But do you really need to compile 2000 functions?\" Yeah. Probably more actually. I can mess around with object culling, but if I want somewhat realistic imagery, I need a lot of objects. Maybe it's not 2000 functions, exactly, but it will certainly be the same level of complexity at the end of the day. The fact that I could easily go up to kernels with 200,000 lines of code in OpenCL was really reassuring that it could handle almost any task I could throw at it.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"The truth is that I would love to get this engine to work in realtime. It's runtime is fast enough that I should be able to. All I need to do is find clever ways to mask the compile time. That's easy enough if the compile time is less than a second, but 10 seconds is a little too long. 26 seconds is completely unreasonable.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"At the end of the day, it will almost certainly be faster to compile old-school C with OpenCL than it will be to compile Julia. Also, even if the OpenCL JIT compiler is too slow, I can just compile my own SPIRV and pass that in directly.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"So...","category":"page"},{"location":"death/#Let's-talk-Julia","page":"This Package Is Dead","title":"Let's talk Julia","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Alright. Now for the elephant in the room. Am I quitting Julia?","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Kinda. I am intending to finish up my MIT projects and then take a break from the language.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"There is a possibility that Julia compile times get way better in the future – even sub 1 second – but I don't see them ever catching up to OpenCL. Even if they did catch up, I am really burnt out from Julia programming right now. Like I said before, the more I embrace Julia tooling, the less I feel like I actually understand the code that I'm writing and I don't like that feeling. For this reason, even if compile times go down, I don't know if I'll ever feel comfortable returning to the language for this project. But feelings change. Ideas change. There could be a future timeline where I come back. I just don't know what it will take to bump me over to that timeline.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"I don't want to make this a \"hit piece\" against the language or anything. I do genuinely feel it is great and has the best GPGPU ecosystem in the business. But (for me) it's really bogged down by Julia, itself. I have a lot of small (and large) issues with the language, but most of those can actually be seen in the Julia developer survey as well, so I hope they will be ironed out soon enough. Rather than discussing any of this in detail, I think it's best to keep this section light and talk about my personal feelings in using the language for so long (since 0.3).","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"I will start by saying that higher level languages have always been difficult for me to understand. I know loops. I know functions. I know conditionals.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"When I see matlab code, my eyes bug out. I don't know what to look for or how to reason about the text in front of me because the things I just listed are usually missing from the code entirely. It becomes even harder to read when your code starts to look too much like math.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Julia has a kinda similar problem. There are all these functions I just \"need to know about\" to write performant code. I need @inbounds to stop Julia from checking my bounds for me. I need @generated functions to do metaprogramming for me. I need abstract types and multiple dispatch and function closures and runtime generated functions and... It's just so much stuff I need to think about and I feel like I am in a constant fight with the compiler.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Back when I was writing the Algorithm Archive, I used to write the initial code snippets in C++. Why? I like C++. It's C, but with a few new tools sprinkled in.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Well, that's what I thought. But C++14 is way different than C++11, which is obviously incredibly different than C99. So when you write C++ code, there will always be someone, somewhere critiquing it and saying, \"well, you should have done it this way.\"","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"That's what happens when you give programmers too many tools. All of a sudden, the right approach is unclear. In fact, there is probably no objectively \"correct\" answer, but if you ask anyone for advice, your solution was \"objectively wrong.\"","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"That's how I have felt writing Julia code. It just always feels like I'm looking over my shoulder and doing something wrong. It's really taken away my love of programming.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"The problem is that in this case, my gut was right! evaling Exprs ended up being faster and more flexible. But I know there will be a Julia user somewhere saying, \"Ah, but you did your @generated functions wrong.\" And I think you might be right. There could have been a way to do things faster that I just didn't know about. But that's the core problem.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Going back to C was a huge breath of fresh air. I recognize I am in my \"honeymoon phase\" right now and that feeling will die off soon, but for now, I am happy enough. I prefer simplicity to ease of use. At least for now.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"I don't really have a way to wrap this up, so...","category":"page"},{"location":"death/#Let's-look-at-the-code.","page":"This Package Is Dead","title":"Let's look at the code.","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"I wrote two quick examples for performance testing. To be honest, they are ugly. I guess I could clean them up, but I don't care to.","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"Long story short, I created 20 functions, and then looped through them all in a kernel and executing them all on each thread. I would then increase the number of functions by concatenating things together into a big set of functions.","category":"page"},{"location":"death/#@generated-method","page":"This Package Is Dead","title":"@generated method","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"using KernelAbstractions\nusing AMDGPU\n\nf_1(x) = x + 1\nf_2(x) = x + 2\nf_3(x) = x + 3\nf_4(x) = x + 4\nf_5(x) = x + 5\nf_6(x) = x + 6\nf_7(x) = x + 7\nf_8(x) = x + 8\nf_9(x) = x + 9\nf_10(x) = x + 10\nf_11(x) = x + 11\nf_12(x) = x + 12\nf_13(x) = x + 13\nf_14(x) = x + 14\nf_15(x) = x + 15\nf_16(x) = x + 16\nf_17(x) = x + 17\nf_18(x) = x + 18\nf_19(x) = x + 19\nf_20(x) = x + 20\n\n@generated function call_fxs(fxs, fidx, args...)\n    N = length(fxs.parameters)\n    quote\n       Base.Cartesian.@nif $(N+1) d->fidx==d d->return fxs[d](args...) d->error(\n\"fidx oob\")\n    end\nend\n\nfunction run(n)\n    @kernel function call_fxs_kernel(a, fxs)\n        i = @index(Global, Linear)\n        for j = 1:length(fxs)\n            @inbounds a[i] = call_fxs(fxs, j, a[i])\n        end\n    end\n\n    a = AMDGPU.zeros(10)\n    #a = zeros(10)\n    @time begin\n        fxs = (f_1, f_2, f_3, f_4, f_5, f_6, f_7, f_8, f_9, f_10,\n               f_11, f_12, f_13, f_14, f_15, f_16, f_17, f_18, f_19, f_20)\n        base_fxs = fxs\n        for i = 2:n\n            fxs = (fxs..., base_fxs...)\n        end\n        println(length(fxs))\n        backend = get_backend(a)\n        kernel = call_fxs_kernel(backend, 256)\n        AMDGPU.@time begin\n            kernel(a, fxs; ndrange = length(a))\n            synchronize(backend)\n        end\n    end\n    @time begin\n        AMDGPU.@time begin\n            kernel(a, fxs; ndrange = length(a))\n            synchronize(backend)\n        end\n    end\nend","category":"page"},{"location":"death/#Fable-method","page":"This Package Is Dead","title":"Fable method","text":"","category":"section"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"You need to use some tooling from my latest remove_points branch:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"using Fable\nusing MacroTools\nusing KernelAbstractions\nusing AMDGPU\n\nmacro fable_run(ex)\n    esc(ex)\nend\n\nstruct Exe{F}\n    f::F\nend\n\nfunction Exe(expr::Expr, name, backend) \n    eval(expr)\n    eval(:(Exe(eval($name)($backend))))\nend\n\nfunction (E::Exe{F})(args...; kwargs...) where F \n    E.f(args...; kwargs...)\nend \n\nfunction combine_to_fx(name, fums)\n    def = Dict([:name => name, :args => Any[:x], :kwargs => Any[],\n                :body => fums.body, :whereparams => ()])\n    MacroTools.combinedef(def)\nend\n\nfunction create_kernel(name, fxs)\n    final_body = Expr(:block,\n                      :(i = @index(Global, Linear)),\n                      fxs.body)\n\n    def = Dict([:name => name, :args => Any[:x], :kwargs => Any[],\n                :body => final_body, :whereparams => ()])\n    Expr(:macrocall, Symbol(\"@kernel\"), :(), MacroTools.combinedef(def))\nend\n\nfunction premeh(n)\n\n    f_1 = @fum f_1(x) = @inbounds x[i] += 1\n    f_2 = @fum f_2(x) = @inbounds x[i] += 2\n    f_3 = @fum f_3(x) = @inbounds x[i] += 3\n    f_4 = @fum f_4(x) = @inbounds x[i] += 4\n    f_5 = @fum f_5(x) = @inbounds x[i] += 5\n    f_6 = @fum f_6(x) = @inbounds x[i] += 6\n    f_7 = @fum f_7(x) = @inbounds x[i] += 7\n    f_8 = @fum f_8(x) = @inbounds x[i] += 8\n    f_9 = @fum f_9(x) = @inbounds x[i] += 9\n    f_10 = @fum f_10(x) = @inbounds x[i] += 10\n    f_11 = @fum f_11(x) = @inbounds x[i] += 11\n    f_12 = @fum f_12(x) = @inbounds x[i] += 12\n    f_13 = @fum f_13(x) = @inbounds x[i] += 13\n    f_14 = @fum f_14(x) = @inbounds x[i] += 14\n    f_15 = @fum f_15(x) = @inbounds x[i] += 15\n    f_16 = @fum f_16(x) = @inbounds x[i] += 16\n    f_17 = @fum f_17(x) = @inbounds x[i] += 17\n    f_18 = @fum f_18(x) = @inbounds x[i] += 18\n    f_19 = @fum f_19(x) = @inbounds x[i] += 19\n    f_20 = @fum f_20(x) = @inbounds x[i] += 20\n\n    fxs = fuse_fums([(f_1(), f_2(), f_3(), f_4(), f_5(), f_6(), f_7(), f_8(), f_\n9(), f_10(), f_11(), f_12(), f_13(), f_14(), f_15(), f_16(), f_17(), f_18(), f_1\n9(), f_20()) for i = 1:n]...)\n    backend = get_backend(ROCArray([1]))\n    Exe(create_kernel(:check, fxs), :check, backend)\nend\n\nfunction meh(exe)\n    \n    a = AMDGPU.zeros(10)\n    backend = get_backend(a)\n    #a = zeros(10)\n\n    AMDGPU.@time exe(a; ndrange = length(a))\n    AMDGPU.@time exe(a; ndrange = length(a))\n    synchronize(backend)\nend","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"To avoid the conflicting world age issue, you need to run this as:","category":"page"},{"location":"death/","page":"This Package Is Dead","title":"This Package Is Dead","text":"exe = premeh(n)\nmeh(exe)","category":"page"},{"location":"layering/#Layering","page":"Layering","title":"Layering","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"Fable.jl has multiple layer types that can be composed together to create a final image (or frame in a video). These layers indicate how the user would like to create an object or field. Right now, the following layers are available:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"ColorLayer: This layer is essentially a single color spread across some number of pixels in a rectangle.\nShaderLayer: This layer is a \"shader\" that uses a FableUserMethod to color every pixel in a rectangle.\nImageLayer: This layer is used to import images generated outside of Fable.jl. Note that remedial resizing functions are available, but these need to be cleaned up in the future.\nFableLayer: This layer is for using Iterated Function Systems and generating objects via fractals.","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"These layers eventually write to their respective canvas objects, which are composed into a final image or frame via:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"    write_image(layer; filename = \"check.png\")\n    write_image([layers]; filename = \"check.png\")\n    write_video!(video_out, layers)\n    write_video!(video_out, [layers])","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"As an important note, even though the canvas for each layer is essentially an Array (or CuArray / ROCArray) of RGBA values (pixels), the layers, themselves are created with the following arguments:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"world_size: The \"world size\" is the size of the world the layer covers.  For example, if you want to render a unit circle, you might want to make sure the world size is roughly 2times 2 in size, otherwise, you might clip part of the object!\nppu: the PPU unit stands for \"pixels per unit\" and is similar to DPI (Dots Per Inch) used in printing. The idea here is that each unit of your world must have a certain number of pixels in it. Importantly, this allows you to dynamically scale your visualization without changing object position.\nposition: This is the position (in the physical units of your world) of the center of your layer. This helps with compositing layers at different locations.","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"To get a better understanding of how these work, here are some quick examples:","category":"page"},{"location":"layering/#Color-Layers","page":"Layering","title":"Color Layers","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"The ColorLayer is likely the simplest layer provided by Fable.jl. To generate a layer that is only a single color, you just need to create the layer and then run the write_image(...) function, like so:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"function layering_example(; ArrayType = Array)\n\n    world_size = (9*0.15, 16*0.15)\n    ppu = 1920/world_size[2]\n\n    clayer = ColorLayer(RGB(0.5, 0.5, 0.5); world_size = world_size, ppu = ppu,\n                        ArrayType = ArrayType)\n\n    write_image(clayer; filename = \"out.png\")\nend\n","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"Running this, will provide the following image:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"(Image: Color Layer Example)","category":"page"},{"location":"layering/#Shader-Layers","page":"Layering","title":"Shader Layers","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"Shader Layers are a bit more complicated than Color Layers, but are ultimately user-specified functions spread across an image. So, let's say the user specified the following FableUserMethod:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"radial = @fum function radial(y, x; origin = (0,0))\n    r = sqrt((x-origin[2])*(x-origin[2]) + (y-origin[1])*(y-origin[1]))\n\n    red = 1\n    green = min(1, 1/r)\n    blue = 1\n    alpha = min(1, 1/r)\n\n    return RGBA{Float32}(red, green, blue, alpha)\nend","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"This should essentially create a white circle that fades out and also turns pink as it goes further from the center of the image. To run this, you can generate a ShaderLayer like so:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"function shader_example(fum; res = (1080,1920), ArrayType = Array,\n                        filename = \"out.png\")\n\n    layer = ShaderLayer(fum; ArrayType = ArrayType, world_size = (9/4, 4),\n                        ppu = 1920/4)\n\n    run!(layer)\n\n    write_image(layer; filename = filename)\nend\n\nshader_example(radial)","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"Which will create the following image (with a black background):","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"(Image: Shader Layer Example)","category":"page"},{"location":"layering/#Image-Layers","page":"Layering","title":"Image Layers","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"As mentioned above, image layers are a work-in-progress. In particular, resizing is a bit finicky and need a little rework. For now, it works like so:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"ilayer = ImageLayer(img)\nilayer = ImageLayer(filename)\nwrite_image(ilayer, filename_2)","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"It can also take all the same arguments as other layers (position, ppu, and world_size), but the resizing is done in a very naive way, so if the image looks odd through Fable.jl, it might be best to figure out the exact pixel size you need and to make the image fit those dimensions with another program.","category":"page"},{"location":"layering/#Fable-Layers-and-combing-layers-together","page":"Layering","title":"Fable Layers and combing layers together","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"Because Fable Layers are a bit tricky, there are additional examples in the documentation to describe how they work. For now, I will show an example of how you might composite two layers together by modifying the example shown for the Color Layer above:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"function layering_example(num_particles, num_iterations; ArrayType = Array)\n\n    world_size = (9*0.15, 16*0.15)\n    ppu = 1920/world_size[2]\n\n    square = define_rectangle(position = [0.0,0.0],\n                              rotation = pi/4,\n                              color = RGBA(1,0,1))\n    flayer = FableLayer(; ArrayType = ArrayType, H1 = square,\n                          world_size = world_size, ppu = ppu,\n                          num_particles = num_particles,\n                          num_iterations = num_iterations)\n    clayer = ColorLayer(RGB(0.5, 0.5, 0.5); world_size = world_size, ppu = ppu,\n                        ArrayType = ArrayType)\n\n    layers = [clayer, flayer]\n\n    run!(layers)\n\n    write_image(layers; filename = \"out.png\")\nend","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"This will provide the following image:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"(Image: Layering Example)","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"Note that the clayer (Color Layer) is written before the flayer (Fable Layer). In general, the first layer acts as the base layer for rendering and acts as your \"camera\" for viewing all other layers. This might need a better abstraction in the future, but works for now.","category":"page"},{"location":"research_directions/#Research-Directions","page":"Research Directions","title":"Research Directions","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Fable.jl is an open research project with the goal of creating a new, general purpose rendering engine based on Iterated Function Systems (IFS).","category":"page"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Here is a quick list of various research directions for the project:","category":"page"},{"location":"research_directions/#Performance","page":"Research Directions","title":"Performance","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Right now, Fable is using a naive chaos game kernel for all visualizations. It would be interesting to explore higher-performance methods for this. In addition, object rendering is currently done layer-by-layer and it would be interesting to be able to render multiple objects with the same IFS. Relevant issue.","category":"page"},{"location":"research_directions/#Generalizations","page":"Research Directions","title":"Generalizations","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Right now, all fractals are made by first starting with a set of equations and then drawing those equations, but it would be interesting to explore the other direction. If the kernels are performant enough, we can do multiple IFS iterations and use some form of optimal control to dynamically learn equations from an input image. This would mean we could essentially turn any image into a fractal, similar to fractal compression. Relevant Issue.","category":"page"},{"location":"research_directions/#Synergy-with-other-rendering-methods","page":"Research Directions","title":"Synergy with other rendering methods","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"There are still advantages to using raytracing, raymarching, or rasterization, but performing clear analyses between the methods and using them together to create a general-purpose rendering library would be an interesting direction.","category":"page"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"If you are at all interested in helping with this project, please start discussions on the relevant issues or otherwise create a new one!","category":"page"},{"location":"examples/smear/#A-Simple-Smear","page":"Simple Smears","title":"A Simple Smear","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Animations are made by stitching together a series of images to give the illusion of motion. When creating an animation, we can choose the number of images we show to our viewers every second. Cinematic movies are typically shown at 24 frames per second (fps). Video games do not usually have a set fps value, but most people usually prefer 60 or higher. Youtube videos can be set to whatever you want, but I typically prefer either 30 or 60 depending on the situation.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Now here's a weird quirk of the human brain. Old-school animations are usually 24 fps, but seem incredibly smooth. If you play a video game at 24 fps, it can sometimes be nauseating.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Why?","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Well, there is no hard answer to this, but video game engines are tasked at showing sometimes thousands of objects to you in real time. This is a really demanding process for your graphics card, so engines will do whatever they can to render things as quickly as possible while still being correct. Even worse for the game engine, it does not always know it's next frame because it has to take the actions of the player into account.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"This is starkly contrasting the animation industry where it might take days to draw even a single frame. Because the entire movie has been drawn on a storyboard before-hand, the artists know what to draw and how to guide the viewer to the next important scene. After months of hard work, all the animators come together and coalesce their art into the final video.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"So let's compare and contrast the difference between these two approaches. If a game engine is given 3 frames to move a circle from the upper left to lower right of the screen, it will render the circle at the start and end location along with the intermediary frames, like so:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Frame 1 Intermediate Frame Final Frame\n(Image: frame_1) (Image: frame_2) (Image: frame_3)","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Animators will do things a little differently. The start and end will look the same, but the intermediary frame will be squashed to show the direction of motion:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Frame 1 Intermediate Frame Final Frame\n(Image: frame_1) (Image: frame_2) (Image: frame_3)","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"The intermediary frame is called a smear frame and this technique is used almost everywhere in modern animation. If you have ever seen a really smooth animation, it's probably because there were really good smears between different character positions. Smear frames are also why characters might look a little weird when you pause an animated video at the wrong place.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Simply put: if an animation lacks smear frames, it might start to look like a low fps video game. We want to avoid that as best as we can!","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"So, let's get to it!","category":"page"},{"location":"examples/smear/#Example","page":"Simple Smears","title":"Example","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"To start, I will create a function that use the num_particles, and num_iterations for the naive chaos game kernel. Note in this case, I am also using ArrayType for the Array Type (Array for CPU or CuArray for GPU), and num_frames for the total number of frames. Finally, I will create an output_type variable that can be either :video, or :image to output to video (out.mp4) or images (check*.png):","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"using Fable, CUDA, AMDGPU\n\nfunction main(num_particles, num_iterations, total_frames; ArrayType = Array,\n              output_type = :video)\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Now I will define the image and video parameters:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # define image domain\n    world_size = (9, 16)\n    ppu = 1920 / 16\n    res = (1080, 1920)\n    layer = FableLayer(; ArrayType = ArrayType,\n                         world_size = world_size, ppu = ppu,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    # defining video parameters\n    if output_type == :video\n        video_out = open_video(res; framerate = 30, filename = \"out.mp4\",\n                               encoder_options = (crf=23, preset=\"medium\"))\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Note that the video will stitch together a series of frames, so we still need the pixels from layer hanging around. Now we define the ball:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # define ball parameters\n    position = [-2.0, -2.0]\n    ball = define_circle(; position = position,\n                           radius = 1.0,\n                           color = (1,1,1))","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"And now we start getting ready for the smear frame transformation:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # fractal inputs to track changes in position, scale, and theta for smear \n    object_position = fi(\"object_position\", position)\n    scale = fi(\"scale\", (1,1))\n    theta = fi(\"theta\", 0)\n\n    # first defining the fractal user method\n    smear = Smears.stretch_and_rotate(object_position = object_position,\n                                      scale = scale, theta = theta)\n\n    # now turning it into a fractal operator\n    smear_transform = fee(Hutchinson, FableOperator(smear))","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"For this, we are creating fractal inputs (object_position, scale, and theta) for the stretch_and_rotate fractal user method. We then turn this into a fractal operator. Note that fractal inputs are good for when you need to update the value of certain parameters on the fly. For clarity, here is the stretch_and_rotate fractal user method:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"stretch_and_rotate = @fum function stretch_and_rotate(\n    x,y;\n    object_position = (0,0),\n    scale = (1,1),\n    theta = 0)\n\n    y = (y - object_position[1])*scale[1]\n    x = (x - object_position[2])*scale[2]\n\n    temp_x = x*cos(theta) - y*sin(theta)\n    temp_y = x*sin(theta) + y*cos(theta)\n\n    x = temp_x + object_position[2]\n    y = temp_y + object_position[1]\n    return (y,x)\nend","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"After this, we need to attach the newly generated operators to the FableLayer:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # attaching each operator to the layer\n    layer.H = ball\n    layer.H_post = smear_transform","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Finally, we have the animation loop:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    for i = 1:total_frames\n\n        # changing ball position\n        radius = 1.0\n        pos = [-2.0+4*(i-1)/(total_frames-1),\n               -2.0+4*(i-1)/(total_frames-1)]\n\n        # creating a value that grows as it gets closer to total_frames / 2\n        # and shrinks as it gets closer to total_frames\n        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)\n\n        # modifying fractal inputs for smear\n        set!(object_position, pos)\n        set!(scale, (1,scale_x))\n        set!(theta, pi/4)\n\n        run!(layer)\n\n        if output_type == :video\n            write_video!(video_out, [layer])\n        elseif output_type == :image\n            filename = \"check\"*lpad(i,5,\"0\")*\".png\"\n            write_image([layer], filename)\n        end\n\n        # clearing frame\n        zero!(layer)\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"This does 4 things:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"It updates the circle at every step.\nIt resets the object_position, scale, and theta for the smear_trasnform.\nIt outputs to either video or image.\nIt sets the canvas values back to 0 for the next frame","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Once this is done, all we need to do is close the video (if we were outputting to video at all:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    if (output_type == :video)\n        close_video(video_out)\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"If we run main(10000, 10000, 10, CuArray; output_tupe = :video), we will get the following video:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"(Image: smear_video)","category":"page"},{"location":"examples/smear/#Just-the-code","page":"Simple Smears","title":"Just the code","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"And here is the full code:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"function smear_example(num_particles, num_iterations, total_frames;\n                       ArrayType = Array, output_type = :video)\n    FloatType = Float32\n\n    # define image domain\n    world_size = (9, 16)\n    ppu = 1920 / 16\n    res = (1080, 1920)\n    layer = FableLayer(; ArrayType = ArrayType, FloatType = FloatType,\n                         world_size = world_size, ppu = ppu,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    # defining video parameters\n    if output_type == :video\n        video_out = open_video(res; framerate = 30, filename = \"out.mp4\")\n    end\n\n    # define ball parameters\n    object_position = fi(\"object_position\", [-2.0, -2.0])\n    ball = define_circle(; position = object_position,\n                           radius = 1.0,\n                           color = (1,1,1))\n\n    # fractal inputs to track changes in position, scale, and theta for smear \n    scale = fi(\"scale\", (1,1))\n    theta = fi(\"theta\", 0)\n\n    # first defining the fractal user method\n    smear = Smears.stretch_and_rotate(object_position = object_position,\n                                      scale = scale, theta = theta)\n\n    # now turning it into a fractal operator\n    smear_transform = fee(Hutchinson, fo(smear))\n\n    layer.H = ball\n    layer.H_post = smear_transform\n\n    for i = 1:total_frames\n\n        # changing ball position\n        radius = 1.0\n        pos = [-2.0+4*(i-1)/(total_frames-1),\n               -2.0+4*(i-1)/(total_frames-1)]\n\n        # creating a value that grows as it gets closer to total_frames / 2\n        # and shrinks as it gets closer to total_frames\n        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)\n\n        # modifying fractal inputs for smear\n        set!(object_position, pos)\n        set!(scale, (1,scale_x))\n        set!(theta, pi/4)\n\n        run!(layer)\n\n        if output_type == :video\n            write_video!(video_out, [layer])\n        elseif output_type == :image\n            filename = \"check\"*lpad(i,5,\"0\")*\".png\"\n            write_image([layer]; filename=filename)\n        end\n\n        # clearing frame\n        zero!(layer)\n    end\n\n    if (output_type == :video)\n        close_video(video_out)\n    end\n\nend","category":"page"},{"location":"examples/swirled_square/#A-Swirled-Square","page":"Rotating Square","title":"A Swirled Square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"This is a quick example to show how to use Fable.jl","category":"page"},{"location":"examples/swirled_square/#Step-1:-create-a-square","page":"Rotating Square","title":"Step 1: create a square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"First, we should create a square. To do this, we need to set up Fable with the right parameters:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    # Physical space location. \n    world_size = (9*0.15, 16*0.15)\n\n    # Pixels per unit space\n    # The aspect ratio is 16x9, so if we want 1920x1080, we can say we want...\n    ppu = 1920/world_size[2]\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Right now, this part of the API is in flux, but we need some sort of physical world to hold the objects in, so we set this to be some size (world_size = (9*0.15, 16*0.15)). We also define the Pixels Per Unit or ppu value. The resolution should be the world_size * ppu, so if we want a 1920x1080 image, we need to set the ppu accordingly (here we set it as 1920/world_size[2]). This will be replaced with a camera struct eventually.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Now we need to define a color. This can be done by passing in an array or tuple (such as color = [1.0, 0, 0, 1] for red), or as an array of arrays or tuples, like:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    colors = [[1.0, 0.25, 0.25,1],\n              [0.25, 1.0, 0.25, 1],\n              [0.25, 0.25, 1.0, 1],\n              [1.0, 0.25, 1.0, 1]]\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"In this case, each row of the array will define the color of a different quadrant of the square. Now we can define our fractal executable...","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"H = define_square(; position = [0.0, 0.0], rotation = pi/4, color = colors)","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Here, ArrayType can be either an Array or CuArray depending whether you would like to run the code on the CPU or (CUDA / AMD) GPU. num_particles and num_iterations are the number of points we are solving with for the chaos game and the number of iterations for each point. The higher these numbers are, the better resolved our final image will be. Notationally, we are using the variable H to designate a Hutchinson operator, which is the mathematical name for a function set.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Finally, we need to attach this function to the layer and run everything with the run!(...) function and write it to an image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    layer = FableLayer(; ArrayType = ArrayType, logscale = false,\n                         world_size = world_size, ppu = ppu, H = H,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n\n    write_image(layer; filename = \"out.png\")\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Note that the H = H keyword argument is the one actually defining H as the first Hutchinson operator for the FableLayer. After running this, we will get the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a simple square)","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"The full code can be found at the bottom of this page","category":"page"},{"location":"examples/swirled_square/#Step-2:-swirl-the-square","page":"Rotating Square","title":"Step 2: swirl the square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Next, we will try to \"swirl the square\" by also adding another fractal executable to the mix, the swirl operator (defined already in Fable.jl):","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"swirl = @fum function swirl(x, y)\n    r = sqrt(y*y + x*x)\n\n    v1 = x*cos(r*r) + y*sin(r*r)\n    v2 = x*sin(r*r) - y*cos(r*r)\n\n    y = v1\n    x = v2\n    return point(y,x)\nend","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Here, we are using the @fum syntax to show how users might define their own operators. The same can be done for colors.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"The code here does not change significantly, except that we create a H_post and add it to the fractal_flame(...) function:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"...\n    H_post = Hutchinson(swirl_operator)\n\n    layer = FableLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H = H, H_post = H_post,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n...","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"There are a few nuances to point out:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"We are using Shaders.previous, which simply means that the swirl will use whatever colors were specified in H.\nFable operators can be called with fee or Hutchinson and require Array or Tuple inputs.\nfinal = true, means that this is a post processing operation. In other words, H creates the object primitive (square), and H_post always operates on that square.\nWe are specifying the Floating Type, FloatType, as Float32, but that is not necessary.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Once this is run, it should provide the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a swirled square)","category":"page"},{"location":"examples/swirled_square/#Step-3:-a-different-kind-of-swirl","page":"Rotating Square","title":"Step 3: a different kind of swirl","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Now some people might be scratching their heads at the previous result. If we are solving with both H and H_post, why does it look like two separate actions instead of one combined one? In other words, why is the swirl so clearly different than the square operation?","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"This is because we operate on two separate sets of points. H creates object primitives. Every step of the simulation, we will read from the points after H operates on them. H_post works on a completely different location in memory specifically for image output. If we want, we can make H_post operate on the object, itself, by creating a new fractal executable:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    final_H = fee(Hutchinson, [H, H_post])\n\n    layer = FableLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H = final_H\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"which will create the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a swirled square (again))","category":"page"},{"location":"examples/swirled_square/#The-full-example","page":"Rotating Square","title":"The full example","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"function square_example(num_particles, num_iterations;\n                        ArrayType = Array,\n                        dark = true,\n                        transform_type = :standard,\n                        filename = \"out.png\")\n    # Physical space location. \n    world_size = (9*0.15, 16*0.15)\n\n    # Pixels per unit space\n    # The aspect ratio is 16x9, so if we want 1920x1080, we can say we want...\n    ppu = 1920/world_size[2]\n\n    colors = [[1.0, 0.25, 0.25,1],\n              [0.25, 1.0, 0.25, 1],\n              [0.25, 0.25, 1.0, 1],\n              [1.0, 0.25, 1.0, 1]]\n\n    H = define_square(; position = [0.0, 0.0], rotation = pi/4,  color = colors)\n    swirl_operator = fo(Flames.swirl)\n    H_post = nothing\n    if transform_type == :outer_swirl\n        H_post = Hutchinson(swirl_operator)\n    elseif transform_type == :inner_swirl\n        H = fee(Hutchinson, [H, Hutchinson(swirl_operator)])\n    end\n\n    layer = FableLayer(; ArrayType = ArrayType, logscale = false,\n                         world_size = world_size, ppu = ppu,\n                         H = H, H_post = H_post,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n\n    write_image(layer; filename = filename)\nend\n","category":"page"},{"location":"#What-is-Fable?","page":"General Information","title":"What is Fable?","text":"","category":"section"},{"location":"","page":"General Information","title":"General Information","text":"Fable is an animation engine that attempts to create a general-purpose rendering engine via Iterated Function Systems (IFSs).","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"This package is no longer maintained. Please read more here.","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"The current Fable.jl API is still in active development, but for those wanting to learn about how to use it, there are several examples available to learn from. Though Fable.jl focuses on creating general-purpose animations with fractals, other rendering modes are either supported or planned to be implemented in the future. For now, the only available rendering modes are:","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"Hutchinson operators: These are used to describe Iterated Function Systems and are the primary focus of Fable.jl\nColors: This mode is somewhat trivial and will just create a layer of a specified color\nShaders: This mode leverages the framework used to describe IFSs to color an image with some user-provided equation.","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"We would like to support rendering via raytracing, raymarching, and rasterization in the future for those who wish to use such features. If you would like to learn how to use any of the existing rendering modes, please look at the layering section of our documentation.","category":"page"},{"location":"#What-are-Iterated-Function-Systems?","page":"General Information","title":"What are Iterated Function Systems?","text":"","category":"section"},{"location":"","page":"General Information","title":"General Information","text":"We plan to put more information in the docs, but there is a great article already describing them in the Algorithm Archive. For now, please go there for more information.","category":"page"},{"location":"#General-Fable.jl-workflow","page":"General Information","title":"General Fable.jl workflow","text":"","category":"section"},{"location":"","page":"General Information","title":"General Information","text":"Fable.jl is generally structured around building a Fable Executable (fee). In the case you want to use the fractal rendering mode, this fee will be a function system, so for a Sierpinski Triangle, it would look like this:","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"beginaligned\nf_1(PA) = fracP+A2 \nf_2(PB) = fracP+B2 \nf_3(PC) = fracP+C2\nendaligned","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"Here, P is some point location and A, B, and C are all vertices of the triangle. For Fable.jl, each function is called a Fable User Method (fum or FableUserMethod). If the user wants to change the variables dynamically, they might create a Fable Input (fi or FableInput). Finally, each function should have some sort of color (or shader) associated with it. Combining two fums for both the position and color functions creates a Fable Operator (fo or FableOperator) So, how do you use Fable.jl?","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"Well...","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"fee, the Fable Executable is the thing you are building\nfi, the Fable Input(s) are the variables needed for your executable\nfo, the Fable Operator is the function you are using in your executable, complete with probability and color or shader information\nfum, the Fable User Method is how users actually create colors and Fable Operators.","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"I am intending to write more docs here, but check out the examples for more information on specifically how to use these.","category":"page"}]
}
