var documenterSearchIndex = {"docs":
[{"location":"research_directions/#Research-Directions","page":"Research Directions","title":"Research Directions","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Fae.jl is an open research project with the goal of creating a new, general purpose rendering engine based on Iterated Function Systems(IFS).","category":"page"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Here is a quick list of various research directions for the project:","category":"page"},{"location":"research_directions/#Performance","page":"Research Directions","title":"Performance","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Right now, Fae is using a naive chaos game kernel for all visualizations. It would be interesting to explore higher-performance methods for this. In addition, object rendering is currently done layer-by-layer and it would be interesting to be able to render multiple objects with the same IFS. Relevant issue.","category":"page"},{"location":"research_directions/#Generalizations","page":"Research Directions","title":"Generalizations","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Right now, all fractals are made by first starting with a set of equations and then drawing those equations, but it would be interesting to explore the other direction. If the kernels are performant enough, we can do multiple IFS iterations and use some form of optimal control to dynamically learn equations from an input image. This would mean we could essentially turn any image into a fractal, similar to fractal compression. Relevant Issue.","category":"page"},{"location":"research_directions/#Synergy-with-other-rendering-methods","page":"Research Directions","title":"Synergy with other rendering methods","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"There are still advantages to using raytracing, raymarching, or rasterization, but performing clear analyses between the methods and using them together to create a general-purpose rendering library would be an interesting direction.","category":"page"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"If you are at all interested in helping with this project, please start discussions on the relevant issues or otherwise create a new one!","category":"page"},{"location":"general_info/#General-Information","page":"General Information","title":"General Information","text":"","category":"section"},{"location":"general_info/","page":"General Information","title":"General Information","text":"The current Fae.jl API is designed such that the user can write down any set of equations to be dispatched onto either their GPU or CPU depending on available hardware. Note that the API is still unstable and subject to change, but there are several general guiding principles we follow that should not be changing in the near future. There are (of course) a few caveats:","category":"page"},{"location":"general_info/#Restricted-IFSs-are-not-supported","page":"General Information","title":"Restricted IFSs are not supported","text":"","category":"section"},{"location":"general_info/","page":"General Information","title":"General Information","text":"The goal of Fae.jl is to allow any user to express whatever IFS they want to solve and then dispatch those equations to the GPU / CPU for solving. There is one caveat here in that we currently do not have a way to express restricted chaos games or restricted IFSs. That is to say we do not have a way to syntactically express equation dependencies. For example, we cannot allow one function will act differently depending on the last function chosen.","category":"page"},{"location":"general_info/#Limited-AMD-GPU-support","page":"General Information","title":"Limited AMD GPU support","text":"","category":"section"},{"location":"general_info/","page":"General Information","title":"General Information","text":"In principle, Fae can somewhat easily support AMD GPUs. It should be as simple as providing support for ROCMArrays like we do for CuArrays, but I have not been able to test this.","category":"page"},{"location":"general_info/","page":"General Information","title":"General Information","text":"Ok, with that out of the way, let's talk about the general structure of Fae.jl","category":"page"},{"location":"general_info/#General-Fae.jl-workflow","page":"General Information","title":"General Fae.jl workflow","text":"","category":"section"},{"location":"general_info/","page":"General Information","title":"General Information","text":"Fae.jl is generally structured around building a Fractal Executable, called either a Hutchinson operator or (more simply) fee. In general, this is a function system, so for a Sierpinski Triangle, your fee will be something like","category":"page"},{"location":"general_info/","page":"General Information","title":"General Information","text":"beginaligned\nf_1(PA) = fracP+A2 \nf_2(PB) = fracP+B2 \nf_3(PC) = fracP+C2\nendaligned","category":"page"},{"location":"general_info/","page":"General Information","title":"General Information","text":"Here, P is some point location and A, B, and C are all vertices of the triangle. For Fae.jl, each function is called a Fractal Operator (fo) and the input variables are Fractal Inputs (fis). Finally, each function should have some sort of color (or shader) associated with it. For this reason, we abstracted out the function interface into another operator called a Fractal User Method (fum). So, how do you use Fae.jl?","category":"page"},{"location":"general_info/","page":"General Information","title":"General Information","text":"Well...","category":"page"},{"location":"general_info/","page":"General Information","title":"General Information","text":"Fee, the fractal executable is the thing you are building\nFi, the fractal input(s) are the variables needed for your executable\nFo, the fractal operator is the function you are using in your executable, complete with probability and color or shader information\nFum, the fractal user method is how users actually create colors and fractal operators.","category":"page"},{"location":"general_info/","page":"General Information","title":"General Information","text":"It's a bit confusing because we had to really rework a lot of the symbolic utilities in Julia so we could do the computation on the GPU.","category":"page"},{"location":"examples/smear/#A-Simple-Smear","page":"Simple Smears","title":"A Simple Smear","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Animations are made by stitching together a series of images to give the illusion of motion. When creating an animation, we can choose the number of images we show to our viewers every second. Cinematic movies are typically shown at 24 frames per second (fps). Video games do not usually have a set fps value, but most people usually prefer 60 or higher. Youtube videos can be set to whatever you want, but I typically prefer either 30 or 60 depending on the situation.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Now here's a weird quirk of the human brain. Old-school animations are usually 24 fps, but seem incredibly smooth. If you play a video game at 24 fps, it can sometimes be nauseating.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Why?","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Well, there is no hard answer to this, but video game engines are tasked at showing sometimes thousands of objects to you in real time. This is a really demanding process for your graphics card, so engines will do whatever they can to render things as quickly as possible while still being correct. Even worse for the game engine, it does not always know it's next frame because it has to take the actions of the player into account.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"This is starkly contrasting the animation industry where it might take days to draw even a single frame. Because the entire movie has been drawn on a storyboard before-hand, the artists know what to draw and how to guide the viewer to the next important scene. After months of hard work, all the animators come together and coalesce their art into the final video.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"So let's compare and contrast the difference between these two approaches. If a game engine is given 3 frames to move a circle from the upper left to lower right of the screen, it will render the circle at the start and end location along with the intermediary frames, like so:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Frame 1 Intermediate Frame Final Frame\n(Image: frame_1) (Image: frame_2) (Image: frame_3)","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Animators will do things a little differently. The start and end will look the same, but the intermediary frame will be squashed to show the direction of motion:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Frame 1 Intermediate Frame Final Frame\n(Image: frame_1) (Image: frame_2) (Image: frame_3)","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"The intermediary frame is called a smear frame and this technique is used almost everywhere in modern animation. If you have ever seen a really smooth animation, it's probably because there were really good smears between different character positions. Smear frames are also why characters might look a little weird when you pause an animated video at the wrong place.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Simply put: if an animation lacks smear frames, it might start to look like a low fps video game. We want to avoid that as best as we can!","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"So, let's get to it!","category":"page"},{"location":"examples/smear/#Example","page":"Simple Smears","title":"Example","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"To start, I will create a function that use the num_particles, and num_iterations for the naive chaos game kernel. Note in this case, I am also using ArrayType for the Array Type (Array for CPU or CuArray for GPU), and num_frames for the total number of frames. Finally, I will create an output_type variable that can be either :video, or :image to output to video (out.mp4) or images (check*.png):","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"using Fae, CUDA, AMDGPU\n\nfunction main(num_particles, num_iterations, total_frames; ArrayType = Array,\n              output_type = :video)\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Now I will define the image and video parameters:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # define image domain\n    res = (1080, 1920)\n    bounds = [-4.5 4.5; -8 8]\n    layer = FractalLayer(res; ArrayType = ArrayType, FloatType = FloatType,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    # defining video parameters\n    if output_type == :video\n        video_out = open_video(res; framerate = 30, filename = \"out.mp4\",\n                               encoder_options = (crf=23, preset=\"medium\"))\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Note that the video will stitch together a series of frames, so we still need the pixels from layer hanging around. Now we define the ball:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # define ball parameters\n    position = [-2.0, -2.0]\n    ball = define_circle(; position = position,\n                           radius = 1.0,\n                           color = (1,1,1))","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"And now we start getting ready for the smear frame transformation:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # fractal inputs to track changes in position, scale, and theta for smear \n    object_position = fi(\"object_position\", position)\n    scale = fi(\"scale\", (1,1))\n    theta = fi(\"theta\", 0)\n\n    fis = [object_position, scale, theta]\n    \n    # first defining the fractal user method\n    smear = Smears.stretch_and_rotate(object_position = object_position,\n                                      scale = scale, theta = theta)\n\n    # now turning it into a fractal operator\n    smear_transform = fee(Hutchinson, [FractalOperator(smear)], fis;\n                          name = \"smear\", final = true, diagnostic = true)","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"For this, we are creating fractal inputs (object_position, scale, and theta) for the stretch_and_rotate fractal user method. We then turn this into a fractal operator. Note that fractal inputs are good for when you need to update the value of certain parameters on the fly. For clarity, here is the stretch_and_rotate fractal user method:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"stretch_and_rotate = @fum function stretch_and_rotate(\n    x,y;\n    object_position = (0,0),\n    scale = (1,1),\n    theta = 0)\n\n    y = (y - object_position[1])*scale[1]\n    x = (x - object_position[2])*scale[2]\n\n    temp_x = x*cos(theta) - y*sin(theta)\n    temp_y = x*sin(theta) + y*cos(theta)\n\n    x = temp_x + object_position[2]\n    y = temp_y + object_position[1]\nend\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"After this, we need to attach the newly generated operators to the FractalLayer:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # attaching each operator to the layer\n    layer.H1 = ball\n    layer.H2 = smear_transform","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Finally, we have the animation loop:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    for i = 1:total_frames\n\n        # changing ball position\n        radius = 1.0\n        pos = [-2.0+4*(i-1)/(total_frames-1),\n               -2.0+4*(i-1)/(total_frames-1)]\n\n        update_circle!(ball, pos, radius)\n\n        # creating a value that grows as it gets closer to total_frames / 2\n        # and shrinks as it gets closer to total_frames\n        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)\n\n        # modifying fractal inputs for smear\n        object_position = set(object_position, pos)\n        scale = set(scale, (1,scale_x))\n        theta = set(theta, pi/4)\n\n        update_fis!(smear_transform, [object_position, scale, theta])\n        run!(layer, bounds)\n\n        if output_type == :video\n            write_video!(video_out, [layer])\n        elseif output_type == :image\n            filename = \"check\"*lpad(i,5,\"0\")*\".png\"\n            write_image([layer], filename)\n        end\n\n        # clearing frame\n        zero!(layer)\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"This does 4 things:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"It updates the circle at every step.\nIt resets the object_position, scale, and theta for the smear_trasnform.\nIt outputs to either video or image.\nIt sets the canvas values back to 0 for the next frame","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Once this is done, all we need to do is close the video (if we were outputting to video at all:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    if (output_type == :video)\n        close_video(video_out)\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"If we run main(10000, 10000, 10, CuArray; output_tupe = :video), we will get the following video:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"(Image: smear_video)","category":"page"},{"location":"examples/smear/#Just-the-code","page":"Simple Smears","title":"Just the code","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"And here is the full code:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"using Fae, CUDA, AMDGPU\n\nfunction main(num_particles, num_iterations, total_frames, ArrayType;\n              output_type = :video)\n    FloatType = Float32\n\n    # define image domain\n    res = (1080, 1920)\n    bounds = [-4.5 4.5; -8 8]\n    layer = FractalLayer(res; ArrayType = ArrayType, FloatType = FloatType,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    # defining video parameters\n    if output_type == :video\n        video_out = open_video(res; framerate = 30, filename = \"out.mp4\",\n                               encoder_options = (crf=23, preset=\"medium\"))\n    end\n\n    # define ball parameters\n    ball = define_circle(; position = [-2.0, -2.0], radius = 1.0, (1,1,1))\n\n    # fractal inputs to track changes in position, scale, and theta for smear \n    object_position = fi(\"object_position\", pos)\n    scale = fi(\"scale\", (1,1))\n    theta = fi(\"theta\", 0)\n\n    fis = [object_position, scale, theta]\n    \n    # first defining the fractal user method\n    smear = Smears.stretch_and_rotate(object_position = object_position,\n                                      scale = scale, theta = theta)\n\n    # now turning it into a fractal operator\n    smear_transform = fee(Hutchinson, [FractalOperator(smear)], fis;\n                          name = \"smear\", final = true, diagnostic = true)\n\n    # attaching each operator to the layer\n    layer.H1 = ball\n    layer.H2 = smear_transform\n\n    for i = 1:total_frames\n\n        # changing ball position\n        radius = 1.0\n        pos = [-2.0+4*(i-1)/(total_frames-1),\n               -2.0+4*(i-1)/(total_frames-1)]\n\n        update_circle!(ball, pos, radius)\n\n        # creating a value that grows as it gets closer to total_frames / 2\n        # and shrinks as it gets closer to total_frames\n        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)\n\n        # modifying fractal inputs for smear\n        object_position = set(object_position, pos)\n        scale = set(scale, (1,scale_x))\n        theta = set(theta, pi/4)\n\n        update_fis!(smear_transform, [object_position, scale, theta])\n        run!(layer, bounds)\n\n        if output_type == :video\n            write_video!(video_out, [layer])\n        elseif output_type == :image\n            filename = \"check\"*lpad(i,5,\"0\")*\".png\"\n            write_image([layer], filename)\n        end\n\n        # clearing frame\n        zero!(layer)\n    end\n\n    if (output_type == :video)\n        close_video(video_out)\n    end\n\nend","category":"page"},{"location":"examples/swirled_square/#A-Swirled-Square","page":"Rotating Square","title":"A Swirled Square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"This is a quick example to show how to use Fae.jl","category":"page"},{"location":"examples/swirled_square/#Step-1:-create-a-square","page":"Rotating Square","title":"Step 1: create a square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"First, we should create a square. To do this, we need to set up Fae with the right parameters:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    # Physical space location. \n    bounds = [-4.5 4.5; -8 8]*0.15\n\n    # Pixel grid\n    res = (1080, 1920)","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Note that this sets up an image resolution, res, and a separate camera with physical units, bounds, so if we are using a 1920 by 1080 image, the bounds can be anything with a 16:9 ratio. Here, we also set the position, pos, the rotation, and scaling factors in x and y, scale_x and scale_y.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Now we need to define a color. This can be done by passing in an array or tuple (such as color = [1.0, 0, 0, 1] for red), or as an array of arrays or tuples, like:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    colors = [[1.0, 0.25, 0.25,1],\n              [0.25, 1.0, 0.25, 1],\n              [0.25, 0.25, 1.0, 1],\n              [1.0, 0.25, 1.0, 1]]\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"In this case, each row of the array will define the color of a different quadrant of the square. Now we can define our fractal executable...","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"H = define_square(; position = [0.0, 0.0], rotation = pi.4, color = colors)","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Here, ArrayType can be either an Array or CuArray depending whether you would like to run the code on the CPU or (CUDA / AMD) GPU. num_particles and num_iterations are the number of points we are solving with for the chaos game and the number of iterations for each point. The higher these numbers are, the better resolved our final image will be. Notationally, we are using the variable H to designate a Hutchinson operator, which is the mathematical name for a function set.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Finally, we need to attach this function to the layer and run everything with the run!(...) function and write it to an image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    layer = FractalLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H1 = H,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer, bounds)\n\n    write_image([layer]; filename = \"out.png\")\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Note that the H1 = H keyword argument is the one actually defining H as the first Hutchinson operator for the FractalLayer. After running this, we will get the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a simple square)","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"The full code will look like ","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"function main(num_particles, num_iterations; ArrayType = Array, dark = true)\n    FloatType = Float32\n\n    # Physical space location. \n    bounds = [-4.5 4.5; -8 8]*0.15\n\n    # Pixel grid\n    res = (1080, 1920)\n\n    if dark\n        colors = [[1.0, 0.25, 0.25,1],\n                  [0.25, 1.0, 0.25, 1],\n                  [0.25, 0.25, 1.0, 1],\n                  [1.0, 0.25, 1.0, 1]]\n    else\n        colors = [[1.0, 0, 0,1],\n                 [0, 1.0, 0, 1],\n                 [0, 0, 1.0, 1],\n                 [1.0, 0, 1.0, 1]]\n    end\n\n    H = define_square(; position = [0.0, 0.0], rotation = pi/4, colors = colors)\n\n    layer = FractalLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H1 = H,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer, bounds)\n\n    write_image(layer; filename = \"out.png\")\n\n\nend\n","category":"page"},{"location":"examples/swirled_square/#Step-2:-swirl-the-square","page":"Rotating Square","title":"Step 2: swirl the square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Next, we will try to \"swirl the square\" by also adding another fractal executable to the mix, the swirl operator (defined already in Fae.jl):","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"swirl = @fum function swirl(x, y)\n    r = sqrt(y*y + x*x)\n\n    v1 = x*cos(r*r) + y*sin(r*r)\n    v2 = x*sin(r*r) - y*cos(r*r)\n\n    y = v1\n    x = v2\nend","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Here, we are using the @fum syntax to show how users might define their own operators. The same can be done for colors.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"The code here does not change significantly, except that we create a H2 and add it to the fractal_flame(...) function:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"...\n    H2 = Hutchinson([Flames.swirl],\n                    [Shaders.previous],\n                    (1.0,);\n                    final = true, diagnostic = true, name = \"2\")\n\n    layer = FractalLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H1 = H, H2 = H2,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer, bounds)\n...","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"There are a few nuances to point out:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"We are using Shaders.previous, which simply means that the swirl will use whatever colors were specified in H1.\nFractal operators can be called with fee or Hutchinson and require Array or Tuple inputs.\nfinal = true, means that this is a post processing operation. In other words, H1 creates the object primitive (square), and H2 always operates on that square.\nWe are specifying the Floating Type, FloatType, as Float32, but that is not necessary.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Once this is run, it should provide the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a swirled square)","category":"page"},{"location":"examples/swirled_square/#Step-3:-a-different-kind-of-swirl","page":"Rotating Square","title":"Step 3: a different kind of swirl","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Now some people might be scratching their heads at the previous result. If we are solving with both H1 and H2, why does it look like two separate actions instead of one combined one? In other words, why is the swirl so clearly different than the square operation?","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"This is because we operate on two separate sets of points. H1 creates object primitives. Every step of the simulation, we will read from the points after H1 operates on them. H2 works on a completely different location in memory specifically for image output. If we want, we can make H2 operate on the object, itself, by creating a new fractal executable:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    final_H = fee(Hutchinson, [H, H2])\n\n    layer = FractalLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H1 = final_H\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer, bounds)\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"which will create the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a swirled square (again))","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Here, again, is the full code:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"function main(num_particles, num_iterations; ArrayType = Array, dark = true)\n    FloatType = Float32\n\n    # Physical space location. \n    bounds = [-4.5 4.5; -8 8]*0.15\n\n    # Pixel grid\n    res = (1080, 1920)\n\n    if dark\n        colors = [[1.0, 0.25, 0.25,1],\n                  [0.25, 1.0, 0.25, 1],\n                  [0.25, 0.25, 1.0, 1],\n                  [1.0, 0.25, 1.0, 1]]\n    else\n        colors = [[1.0, 0, 0,1],\n                 [0, 1.0, 0, 1],\n                 [0, 0, 1.0, 1],\n                 [1.0, 0, 1.0, 1]]\n    end\n\n    H = define_square(; position = [0.0, 0.0], rotation = pi/4, colors = colors,\n                      ArrayType = ArrayType)\n    H2 = Hutchinson([Flames.swirl],\n                    [Shaders.previous],\n                    (1.0,);\n                    diagnostic = true, ArrayType = ArrayType, name = \"2\")\n    final_H = fee(Hutchinson, [H, H2])\n\n    layer = fractal_flame(final_H, num_particles, num_iterations,\n                          bounds, res; ArrayType = ArrayType, FloatType = FloatType)\n\n    filename = \"out.png\"\n    write_image([layer], filename)\nend\n","category":"page"},{"location":"#The-Fractal-Animation-Engine","page":"Home","title":"The Fractal Animation Engine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Fractal Animation Engine (Fae) is an attempt to create a general-purpose rendering method via Iterated Function Systems (IFSs) and fractals.","category":"page"}]
}
