var documenterSearchIndex = {"docs":
[{"location":"time_interface/#Time-Interaface","page":"Time Interface","title":"Time Interaface","text":"","category":"section"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"To be honest, the time interface for Fable.jl is under construction and not quite ready for general use; however, as an animation engine, it does allow users to use some form of \"time\" component for each FableUserMethod.","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"The most important thing to note is that Fable.jl fundamentally animates per frame, not based on real time! This simply means that the variable sent to each FableUserMethod is not time, but the current frame.","category":"page"},{"location":"time_interface/#How-to-use-the-Fable.jl-time-interface","page":"Time Interface","title":"How to use the Fable.jl time interface","text":"","category":"section"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"Right now, simply create a FableUserMethod that uses the frame variable, and then pass some time argument along to your run!(...) function as a keyword argument:","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"run!(layer; time = t)","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"Here t could be a Float that represents the number of seconds, an Int that represents the current frame, or a Unitful quantity (like `1u\"s\") which represents some other unit of time.","category":"page"},{"location":"time_interface/","page":"Time Interface","title":"Time Interface","text":"I'll be adding more to these docs as the time interface becomes more stable, but for now, please feel free to let me know what you think on the relevant issue!","category":"page"},{"location":"postprocessing/#Post-processing","page":"Post Processing","title":"Post processing","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Once you have generated an image via any of the provided Fable Executables (such as Colors, Shaders, or Hutchinson operators), you may want to do additional operations before writing to file. Right now, we support the following operations:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Clipping: This is the process of turning any pixel above a given threshold intensity into another desired color.\nFiltering: This is essentially a convolution with a provided filter, for effects like a Gaussian blur.\nSobel: This is a Sobel filter (without directional information). It is useful for edge detection or simple outlines.\nOutlines: This takes the Sobel information and turns it into a more distinct outline.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"In this discussion, I will also describe how you may write your own post processing option, if you want. All the examples can be found in examples/postprocessing.md.","category":"page"},{"location":"postprocessing/#General-Notes","page":"Post Processing","title":"General Notes","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The postprocess!(...) function is called when using write_image(...) or write_video(...). This means that the post processing step happens after the all FableExecutables have been run(...). Importantly, all post processing steps act exclusively on the canvas for each AbstractLayer type. Each canvas is essentially an Array (CuArray or ROCArray) of RGBA values that are initialized before post processing occurs. Each post processing step is performed in the order they are added to the postprocessing_steps Vector in each AbstractLayer.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"There is no default post process for Shader and Color layers, which essentially means that no post process will be performed unless specified by the user. For FableLayers, there is always a CopyToCanvas(...) post process, which essentially takes the RGBA information from the run(...) function and turns it into a canvas for later post processing steps. In practice, this is a small discrepancy that users should not need to worry about.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"For the following examples, we will be performing post processing on a simple circle created via a FableExecutable:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function quick_circle(num_particles, num_iterations; ArrayType = Array,\n                      filename = \"out.png\")\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType)\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will create a pink circle that looks like this:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A simple circle)","category":"page"},{"location":"postprocessing/#Clipping","page":"Post Processing","title":"Clipping","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"By default, the Clip post process will turn any RGBA value above a pre-defined threshold to another designated color; however, you can change the clip_op(clip operator) to use any function instead of >. You may also change how the intensity is calculated by passing in an intensity_function argument. Fable.jl currently supports the following intensity functions:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"@inline function simple_intensity(c::CT) where CT <: Union{RGB}\n   return (c.r/3) + (c.g/3) + (c.b/3)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"and","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"@inline function perceptive_intensity(c::CT) where CT <: Union{RGBA}\n    return c.alpha * ((0.21 * c.r) + (0.72 * c.g) + (0.07 * c.b))\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The latter is meant to more realistically portray to how humans perceive light.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Clip post process can be created like so:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"clip = Clip(; threshold = 0.5, color = RGBA(0,0,0,1),\n              intensity_function = simple_intensity, clip_op = >)","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Note that the key word arguments above are also the defaults for the Clip post process. Here is a quick example:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function clip_example(num_particles, num_iterations; ArrayType = Array,\n                      filename = \"clip_out.png\")\n\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    clip = Clip(; threshold = 0.5, color = RGBA(1, 1, 0, 1))\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [clip])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will turn our pink ball yellow:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A yellow circle)","category":"page"},{"location":"postprocessing/#Filtering","page":"Post Processing","title":"Filtering","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Filter post process essentially performs a convolution with a provided filter. Convolutions are somewhat complicated to understand, but if you want to learn more, please check out the chapter(s) available on the Algorithm Archive. All the necessary information for understanding how this post process works can be found there, along with an example using the Sobel operator.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"By default, Fable.jl provides the following filters:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Identity: This is a test filter and just returns the exact image back","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function Identity(; filter_size = 3, ArrayType = Array)\n    if iseven(filter_size)\n        filter_size = filter_size - 1\n        @warn(\"filter sizes must be odd! New filter size is \" *\n              string(filter_size)*\"!\")\n    end\n    filter = zeros(filter_size, filter_size)\n    idx = ceil(Int, filter_size*0.5)\n    filter[idx, idx] = 1\n\n    return Filter(filter!, ArrayType(filter), nothing, false)\nend\n","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Gaussian / Blur: these perform a Gaussian blur of the image.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function gaussian(x,y, sigma)\n    return (1/(2*pi*sigma*sigma))*exp(-((x*x + y*y)/(2*sigma*sigma)))\nend\n\nfunction Blur(; filter_size = 3, ArrayType = Array, sigma = 1.0)\n    return Gaussian(; filter_size = filter_size, ArrayType = ArrayType,\n                      sigma = sigma)\nend\n\nfunction Gaussian(; filter_size = 3, ArrayType = Array, sigma = 1.0)\n    if iseven(filter_size)\n        filter_size = filter_size - 1\n        @warn(\"filter sizes must be odd! New filter size is \" *\n              string(filter_size)*\"!\")\n    end\n    if filter_size > 1\n        filter = zeros(filter_size, filter_size)\n        for i = 1:filter_size\n            y = -1 + 2*(i-1)/(filter_size-1) \n            for j = 1:filter_size\n                x = -1 + 2*(j-1)/(filter_size-1) \n                filter[i,j] = gaussian(x, y, sigma)\n            end\n        end\n    else\n        filter = [1.0]\n    end\n\n    filter ./= sum(filter)\n    return Filter(filter!, ArrayType(filter), nothing, false)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Sobel post process also uses a Filter, but it will be discussed separately in the next section.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The only important note here is that because users are creating kernels themselves, it is possible to accidentally create a kernel of a different ArrayType than the layer's canvas. In this case, the kernel will change the array type of the filter and provide the following warning:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Info: filter array type not the same as canvas!\nConverting filter to canvas type...","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Finally, here is a quick example using the Gaussian Blur post process (note you can also use the same post process by calling Gaussian instead in the same way):","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function blur_example(num_particles, num_iterations; ArrayType = Array,\n                      filter_size = 3, filename = \"blur_out.png\")\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    blur = Blur(; filter_size = filter_size)\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [blur])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will produce the following image when using a 100times 100 filter:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A blurred circle)","category":"page"},{"location":"postprocessing/#Sobel-operator","page":"Post Processing","title":"Sobel operator","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The Sobel operator is often called an \"image derivative.\" More information can be found on the Algorithm Archive. In general, this operation can be split into 3 steps:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"A gradient in the x direction (G_x)\nA gradient in the y direction (G_y)\nA sum of both gradients: sqrtG_x^2 + G_y^2","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"As an important note, many implementations of the Sobel operator also return gradient direction information. This part of the operation is not performed in Fable.jl by default.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here is a quick example using the Sobel operator:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function sobel_example(num_particles, num_iterations; ArrayType = Array,\n                       filename = \"sobel_out.png\")\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    sobel = Sobel()\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [sobel])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will produce the following image:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: A sobel circle)","category":"page"},{"location":"postprocessing/#Outlines","page":"Post Processing","title":"Outlines","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Outlines are surprisingly tricky to get right. I will not argue that the Outline implementation in Fable.jl is perfect, but it works well enough for now.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"The current implementation was inspired by Canny edge detection and does the following:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Blurs the given image by some factor related to the user-provided linewidth variable.\nPerforms a Sobel operation on the image to get the image derivative.\nPerforms naive ridge detection, which sets any value in the Sobel-operated canvas above a certain threshold to be the provided outline color. This is essentially a Clip post process from above.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"There are a bunch of key word arguments you can use for Outline:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"outline = Outline(; linewidth = 1,\n                   color = RGBA(1.0, 1.0, 1.0, 1.0),\n                   intensity_function = simple_intensity,\n                   object_outline = false,\n                   threshold = 1/(linewidth*linewidth+1),\n                   sigma = 1)\n","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here, linewidth is the desired line width of the outline, color is the desired color, intensity_function is the intensity function as described in the Clip subsection above, threshold is used for ridge detection, and sigma defines the width of the Gaussian for the blur kernel. The only tricky argument is object_outline, which is specifically for FableLayers. It indicates that the user wants to outline the fractal object, itself, not any inner components from potentially using a FableUserMethod for coloring the fractal object.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here is a quick example using the Outline post process:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function outline_example(num_particles, num_iterations; ArrayType = Array,\n                         filename = \"outline_out.png\", linewidth = 1,\n                         object_outline = false)\n    circle = define_circle(; radius = 0.1, color = [1, 0, 1, 1])\n\n    outline = Outline(; linewidth = linewidth, object_outline = object_outline)\n\n    fl = FableLayer(; H1 = circle, ArrayType = ArrayType,\n                        postprocessing_steps = [outline])\n\n    run!(fl)\n    write_image(fl; filename = filename)\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"This will produce the following image:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"(Image: An outlined circle)","category":"page"},{"location":"postprocessing/#Building-your-own","page":"Post Processing","title":"Building your own","text":"","category":"section"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Finally, we will touch on what is necessary to build a post process from scratch. Right now, this can be done by creating a new AbstractPostProcess struct, similar to those used in the above examples. Here is the Clip post processing struct for reference:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"struct Clip <: AbstractPostProcess\n    op::Function\n    clip_op::Function\n    intensity_function::Function\n    threshold::Number\n    color::CT where CT <: Union{RGB, RGBA}\n    initialized::Bool\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"To be honest, this part of the code is a little sticky right now, so feel free to try to clean it up in a PR, but the minimal AbstractPostProcess struct would look like this:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"struct Minimal <: AbstractPostProcess\n    op::Function\n    initialized::Bool\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Here, op is the provided function the AbstractPostProcess should use, while initialized is a boolean value indicating whether the post process needs initialization. This is useful for post processes that require additional canvas parameters, like the Filter post process:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"mutable struct Filter <: AbstractPostProcess\n    op::Function\n    filter::AT where AT <: Union{Array, CuArray, ROCArray}\n    canvas::AT where AT <: Union{Array, CuArray, ROCArray, Nothing}\n    initialized::Bool\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"If initialized is set to false, the initialize!(...) function will be called when using the post process for the first time. Here is the initialize!(...) function for Filter:","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"function initialize!(filter::Filter, layer::AL) where AL <: AbstractLayer\n    ArrayType = layer.params.ArrayType\n    if !(typeof(filter.filter) <: layer.params.ArrayType)\n        @info(\"filter array type not the same as canvas!\\nConverting filter to canvas type...\")\n        filter.filter = ArrayType(filter.filter)\n    end\n    filter.canvas = ArrayType(zeros(eltype(layer.canvas), size(layer.canvas)))\nend","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Note that all initialize! functions should have the args (filter::Filter, layer::AL). In practice, these functions are usually used to make sure that the post process canvas has the same ArrayType and size as the layer.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"As a final note: when designing an op function to be used for each post process, remember that the ArrayType could be a CuArray or ROCArray, so try to make the functions GPU friendly. This is why many of the post processes are written in KernelAbstractions.","category":"page"},{"location":"postprocessing/","page":"Post Processing","title":"Post Processing","text":"Again, this part of the code is sticky, so if you need to add another post process, feel free to create an issue and we can talk about whether it makes sense to add directly to Fable.jl!","category":"page"},{"location":"layering/#Layering","page":"Layering","title":"Layering","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"Fable.jl has multiple layer types that can be composed together to create a final image (or frame in a video). These layers indicate how the user would like to create an object or field. Right now, the following layers are available:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"ColorLayer: This layer is essentially a single color spread across some number of pixels in a rectangle.\nShaderLayer: This layer is a \"shader\" that uses a FableUserMethod to color every pixel in a rectangle.\nImageLayer: This layer is used to import images generated outside of Fable.jl. Note that remedial resizing functions are available, but these need to be cleaned up in the future.\nFableLayer: This layer is for using Iterated Function Systems and generating objects via fractals.","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"These layers eventually write to their respective canvas objects, which are composed into a final image or frame via:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"    write_image(layer; filename = \"check.png\")\n    write_image([layers]; filename = \"check.png\")\n    write_video!(video_out, layers)\n    write_video!(video_out, [layers])","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"As an important note, even though the canvas for each layer is essentially an Array (or CuArray / ROCArray) of RGBA values (pixels), the layers, themselves are created with the following arguments:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"world_size: The \"world size\" is the size of the world the layer covers.  For example, if you want to render a unit circle, you might want to make sure the world size is roughly 2times 2 in size, otherwise, you might clip part of the object!\nppu: the PPU unit stands for \"pixels per unit\" and is similar to DPI (Dots Per Inch) used in printing. The idea here is that each unit of your world must have a certain number of pixels in it. Importantly, this allows you to dynamically scale your visualization without changing object position.\nposition: This is the position (in the physical units of your world) of the center of your layer. This helps with compositing layers at different locations.","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"To get a better understanding of how these work, here are some quick examples:","category":"page"},{"location":"layering/#Color-Layers","page":"Layering","title":"Color Layers","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"The ColorLayer is likely the simplest layer provided by Fable.jl. To generate a layer that is only a single color, you just need to create the layer and then run the write_image(...) function, like so:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"function layering_example(; ArrayType = Array)\n\n    world_size = (9*0.15, 16*0.15)\n    ppu = 1920/world_size[2]\n\n    clayer = ColorLayer(RGB(0.5, 0.5, 0.5); world_size = world_size, ppu = ppu,\n                        ArrayType = ArrayType)\n\n    write_image(clayer; filename = \"out.png\")\nend\n","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"Running this, will provide the following image:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"(Image: Color Layer Example)","category":"page"},{"location":"layering/#Shader-Layers","page":"Layering","title":"Shader Layers","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"Shader Layers are a bit more complicated than Color Layers, but are ultimately user-specified functions spread across an image. So, let's say the user specified the following FableUserMethod:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"radial = @fum function radial(y, x; origin = (0,0))\n    r = sqrt((x-origin[2])*(x-origin[2]) + (y-origin[1])*(y-origin[1]))\n\n    red = 1\n    green = min(1, 1/r)\n    blue = 1\n    alpha = min(1, 1/r)\n\n    return RGBA{Float32}(red, green, blue, alpha)\nend","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"This should essentially create a white circle that fades out and also turns pink as it goes further from the center of the image. To run this, you can generate a ShaderLayer like so:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"function shader_example(fum; res = (1080,1920), ArrayType = Array,\n                        filename = \"out.png\")\n\n    layer = ShaderLayer(fum; ArrayType = ArrayType, world_size = (9/4, 4),\n                        ppu = 1920/4)\n\n    run!(layer)\n\n    write_image(layer; filename = filename)\nend\n\nshader_example(radial)","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"Which will create the following image (with a black background):","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"(Image: Shader Layer Example)","category":"page"},{"location":"layering/#Image-Layers","page":"Layering","title":"Image Layers","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"As mentioned above, image layers are a work-in-progress. In particular, resizing is a bit finicky and need a little rework. For now, it works like so:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"ilayer = ImageLayer(img)\nilayer = ImageLayer(filename)\nwrite_image(ilayer, filename_2)","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"It can also take all the same arguments as other layers (position, ppu, and world_size), but the resizing is done in a very naive way, so if the image looks odd through Fable.jl, it might be best to figure out the exact pixel size you need and to make the image fit those dimensions with another program.","category":"page"},{"location":"layering/#Fable-Layers-and-combing-layers-together","page":"Layering","title":"Fable Layers and combing layers together","text":"","category":"section"},{"location":"layering/","page":"Layering","title":"Layering","text":"Because Fable Layers are a bit tricky, there are additional examples in the documentation to describe how they work. For now, I will show an example of how you might composite two layers together by modifying the example shown for the Color Layer above:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"function layering_example(num_particles, num_iterations; ArrayType = Array)\n\n    world_size = (9*0.15, 16*0.15)\n    ppu = 1920/world_size[2]\n\n    square = define_rectangle(position = [0.0,0.0],\n                              rotation = pi/4,\n                              color = RGBA(1,0,1))\n    flayer = FableLayer(; ArrayType = ArrayType, H1 = square,\n                          world_size = world_size, ppu = ppu,\n                          num_particles = num_particles,\n                          num_iterations = num_iterations)\n    clayer = ColorLayer(RGB(0.5, 0.5, 0.5); world_size = world_size, ppu = ppu,\n                        ArrayType = ArrayType)\n\n    layers = [clayer, flayer]\n\n    run!(layers)\n\n    write_image(layers; filename = \"out.png\")\nend","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"This will provide the following image:","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"(Image: Layering Example)","category":"page"},{"location":"layering/","page":"Layering","title":"Layering","text":"Note that the clayer (Color Layer) is written before the flayer (Fable Layer). In general, the first layer acts as the base layer for rendering and acts as your \"camera\" for viewing all other layers. This might need a better abstraction in the future, but works for now.","category":"page"},{"location":"research_directions/#Research-Directions","page":"Research Directions","title":"Research Directions","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Fable.jl is an open research project with the goal of creating a new, general purpose rendering engine based on Iterated Function Systems (IFS).","category":"page"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Here is a quick list of various research directions for the project:","category":"page"},{"location":"research_directions/#Performance","page":"Research Directions","title":"Performance","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Right now, Fable is using a naive chaos game kernel for all visualizations. It would be interesting to explore higher-performance methods for this. In addition, object rendering is currently done layer-by-layer and it would be interesting to be able to render multiple objects with the same IFS. Relevant issue.","category":"page"},{"location":"research_directions/#Generalizations","page":"Research Directions","title":"Generalizations","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"Right now, all fractals are made by first starting with a set of equations and then drawing those equations, but it would be interesting to explore the other direction. If the kernels are performant enough, we can do multiple IFS iterations and use some form of optimal control to dynamically learn equations from an input image. This would mean we could essentially turn any image into a fractal, similar to fractal compression. Relevant Issue.","category":"page"},{"location":"research_directions/#Synergy-with-other-rendering-methods","page":"Research Directions","title":"Synergy with other rendering methods","text":"","category":"section"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"There are still advantages to using raytracing, raymarching, or rasterization, but performing clear analyses between the methods and using them together to create a general-purpose rendering library would be an interesting direction.","category":"page"},{"location":"research_directions/","page":"Research Directions","title":"Research Directions","text":"If you are at all interested in helping with this project, please start discussions on the relevant issues or otherwise create a new one!","category":"page"},{"location":"examples/smear/#A-Simple-Smear","page":"Simple Smears","title":"A Simple Smear","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Animations are made by stitching together a series of images to give the illusion of motion. When creating an animation, we can choose the number of images we show to our viewers every second. Cinematic movies are typically shown at 24 frames per second (fps). Video games do not usually have a set fps value, but most people usually prefer 60 or higher. Youtube videos can be set to whatever you want, but I typically prefer either 30 or 60 depending on the situation.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Now here's a weird quirk of the human brain. Old-school animations are usually 24 fps, but seem incredibly smooth. If you play a video game at 24 fps, it can sometimes be nauseating.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Why?","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Well, there is no hard answer to this, but video game engines are tasked at showing sometimes thousands of objects to you in real time. This is a really demanding process for your graphics card, so engines will do whatever they can to render things as quickly as possible while still being correct. Even worse for the game engine, it does not always know it's next frame because it has to take the actions of the player into account.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"This is starkly contrasting the animation industry where it might take days to draw even a single frame. Because the entire movie has been drawn on a storyboard before-hand, the artists know what to draw and how to guide the viewer to the next important scene. After months of hard work, all the animators come together and coalesce their art into the final video.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"So let's compare and contrast the difference between these two approaches. If a game engine is given 3 frames to move a circle from the upper left to lower right of the screen, it will render the circle at the start and end location along with the intermediary frames, like so:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Frame 1 Intermediate Frame Final Frame\n(Image: frame_1) (Image: frame_2) (Image: frame_3)","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Animators will do things a little differently. The start and end will look the same, but the intermediary frame will be squashed to show the direction of motion:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Frame 1 Intermediate Frame Final Frame\n(Image: frame_1) (Image: frame_2) (Image: frame_3)","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"The intermediary frame is called a smear frame and this technique is used almost everywhere in modern animation. If you have ever seen a really smooth animation, it's probably because there were really good smears between different character positions. Smear frames are also why characters might look a little weird when you pause an animated video at the wrong place.","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Simply put: if an animation lacks smear frames, it might start to look like a low fps video game. We want to avoid that as best as we can!","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"So, let's get to it!","category":"page"},{"location":"examples/smear/#Example","page":"Simple Smears","title":"Example","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"To start, I will create a function that use the num_particles, and num_iterations for the naive chaos game kernel. Note in this case, I am also using ArrayType for the Array Type (Array for CPU or CuArray for GPU), and num_frames for the total number of frames. Finally, I will create an output_type variable that can be either :video, or :image to output to video (out.mp4) or images (check*.png):","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"using Fable, CUDA, AMDGPU\n\nfunction main(num_particles, num_iterations, total_frames; ArrayType = Array,\n              output_type = :video)\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Now I will define the image and video parameters:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # define image domain\n    world_size = (9, 16)\n    ppu = 1920 / 16\n    res = (1080, 1920)\n    layer = FableLayer(; ArrayType = ArrayType,\n                         world_size = world_size, ppu = ppu,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    # defining video parameters\n    if output_type == :video\n        video_out = open_video(res; framerate = 30, filename = \"out.mp4\",\n                               encoder_options = (crf=23, preset=\"medium\"))\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Note that the video will stitch together a series of frames, so we still need the pixels from layer hanging around. Now we define the ball:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # define ball parameters\n    position = [-2.0, -2.0]\n    ball = define_circle(; position = position,\n                           radius = 1.0,\n                           color = (1,1,1))","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"And now we start getting ready for the smear frame transformation:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # fractal inputs to track changes in position, scale, and theta for smear \n    object_position = fi(\"object_position\", position)\n    scale = fi(\"scale\", (1,1))\n    theta = fi(\"theta\", 0)\n\n    # first defining the fractal user method\n    smear = Smears.stretch_and_rotate(object_position = object_position,\n                                      scale = scale, theta = theta)\n\n    # now turning it into a fractal operator\n    smear_transform = fee(Hutchinson, FableOperator(smear))","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"For this, we are creating fractal inputs (object_position, scale, and theta) for the stretch_and_rotate fractal user method. We then turn this into a fractal operator. Note that fractal inputs are good for when you need to update the value of certain parameters on the fly. For clarity, here is the stretch_and_rotate fractal user method:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"stretch_and_rotate = @fum function stretch_and_rotate(\n    x,y;\n    object_position = (0,0),\n    scale = (1,1),\n    theta = 0)\n\n    y = (y - object_position[1])*scale[1]\n    x = (x - object_position[2])*scale[2]\n\n    temp_x = x*cos(theta) - y*sin(theta)\n    temp_y = x*sin(theta) + y*cos(theta)\n\n    x = temp_x + object_position[2]\n    y = temp_y + object_position[1]\n    return (y,x)\nend","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"After this, we need to attach the newly generated operators to the FableLayer:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    # attaching each operator to the layer\n    layer.H = ball\n    layer.H_post = smear_transform","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Finally, we have the animation loop:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    for i = 1:total_frames\n\n        # changing ball position\n        radius = 1.0\n        pos = [-2.0+4*(i-1)/(total_frames-1),\n               -2.0+4*(i-1)/(total_frames-1)]\n\n        # creating a value that grows as it gets closer to total_frames / 2\n        # and shrinks as it gets closer to total_frames\n        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)\n\n        # modifying fractal inputs for smear\n        set!(object_position, pos)\n        set!(scale, (1,scale_x))\n        set!(theta, pi/4)\n\n        run!(layer)\n\n        if output_type == :video\n            write_video!(video_out, [layer])\n        elseif output_type == :image\n            filename = \"check\"*lpad(i,5,\"0\")*\".png\"\n            write_image([layer], filename)\n        end\n\n        # clearing frame\n        zero!(layer)\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"This does 4 things:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"It updates the circle at every step.\nIt resets the object_position, scale, and theta for the smear_trasnform.\nIt outputs to either video or image.\nIt sets the canvas values back to 0 for the next frame","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"Once this is done, all we need to do is close the video (if we were outputting to video at all:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"    if (output_type == :video)\n        close_video(video_out)\n    end\n","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"If we run main(10000, 10000, 10, CuArray; output_tupe = :video), we will get the following video:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"(Image: smear_video)","category":"page"},{"location":"examples/smear/#Just-the-code","page":"Simple Smears","title":"Just the code","text":"","category":"section"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"And here is the full code:","category":"page"},{"location":"examples/smear/","page":"Simple Smears","title":"Simple Smears","text":"function smear_example(num_particles, num_iterations, total_frames;\n                       ArrayType = Array, output_type = :video)\n    FloatType = Float32\n\n    # define image domain\n    world_size = (9, 16)\n    ppu = 1920 / 16\n    res = (1080, 1920)\n    layer = FableLayer(; ArrayType = ArrayType, FloatType = FloatType,\n                         world_size = world_size, ppu = ppu,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    # defining video parameters\n    if output_type == :video\n        video_out = open_video(res; framerate = 30, filename = \"out.mp4\")\n    end\n\n    # define ball parameters\n    object_position = fi(\"object_position\", [-2.0, -2.0])\n    ball = define_circle(; position = object_position,\n                           radius = 1.0,\n                           color = (1,1,1))\n\n    # fractal inputs to track changes in position, scale, and theta for smear \n    scale = fi(\"scale\", (1,1))\n    theta = fi(\"theta\", 0)\n\n    # first defining the fractal user method\n    smear = Smears.stretch_and_rotate(object_position = object_position,\n                                      scale = scale, theta = theta)\n\n    # now turning it into a fractal operator\n    smear_transform = fee(Hutchinson, fo(smear))\n\n    layer.H = ball\n    layer.H_post = smear_transform\n\n    for i = 1:total_frames\n\n        # changing ball position\n        radius = 1.0\n        pos = [-2.0+4*(i-1)/(total_frames-1),\n               -2.0+4*(i-1)/(total_frames-1)]\n\n        # creating a value that grows as it gets closer to total_frames / 2\n        # and shrinks as it gets closer to total_frames\n        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)\n\n        # modifying fractal inputs for smear\n        set!(object_position, pos)\n        set!(scale, (1,scale_x))\n        set!(theta, pi/4)\n\n        run!(layer)\n\n        if output_type == :video\n            write_video!(video_out, [layer])\n        elseif output_type == :image\n            filename = \"check\"*lpad(i,5,\"0\")*\".png\"\n            write_image([layer]; filename=filename)\n        end\n\n        # clearing frame\n        zero!(layer)\n    end\n\n    if (output_type == :video)\n        close_video(video_out)\n    end\n\nend","category":"page"},{"location":"examples/swirled_square/#A-Swirled-Square","page":"Rotating Square","title":"A Swirled Square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"This is a quick example to show how to use Fable.jl","category":"page"},{"location":"examples/swirled_square/#Step-1:-create-a-square","page":"Rotating Square","title":"Step 1: create a square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"First, we should create a square. To do this, we need to set up Fable with the right parameters:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    # Physical space location. \n    world_size = (9*0.15, 16*0.15)\n\n    # Pixels per unit space\n    # The aspect ratio is 16x9, so if we want 1920x1080, we can say we want...\n    ppu = 1920/world_size[2]\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Right now, this part of the API is in flux, but we need some sort of physical world to hold the objects in, so we set this to be some size (world_size = (9*0.15, 16*0.15)). We also define the Pixels Per Unit or ppu value. The resolution should be the world_size * ppu, so if we want a 1920x1080 image, we need to set the ppu accordingly (here we set it as 1920/world_size[2]). This will be replaced with a camera struct eventually.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Now we need to define a color. This can be done by passing in an array or tuple (such as color = [1.0, 0, 0, 1] for red), or as an array of arrays or tuples, like:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    colors = [[1.0, 0.25, 0.25,1],\n              [0.25, 1.0, 0.25, 1],\n              [0.25, 0.25, 1.0, 1],\n              [1.0, 0.25, 1.0, 1]]\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"In this case, each row of the array will define the color of a different quadrant of the square. Now we can define our fractal executable...","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"H = define_square(; position = [0.0, 0.0], rotation = pi/4, color = colors)","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Here, ArrayType can be either an Array or CuArray depending whether you would like to run the code on the CPU or (CUDA / AMD) GPU. num_particles and num_iterations are the number of points we are solving with for the chaos game and the number of iterations for each point. The higher these numbers are, the better resolved our final image will be. Notationally, we are using the variable H to designate a Hutchinson operator, which is the mathematical name for a function set.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Finally, we need to attach this function to the layer and run everything with the run!(...) function and write it to an image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    layer = FableLayer(; ArrayType = ArrayType, logscale = false,\n                         world_size = world_size, ppu = ppu, H = H,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n\n    write_image(layer; filename = \"out.png\")\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Note that the H = H keyword argument is the one actually defining H as the first Hutchinson operator for the FableLayer. After running this, we will get the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a simple square)","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"The full code can be found at the bottom of this page","category":"page"},{"location":"examples/swirled_square/#Step-2:-swirl-the-square","page":"Rotating Square","title":"Step 2: swirl the square","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Next, we will try to \"swirl the square\" by also adding another fractal executable to the mix, the swirl operator (defined already in Fable.jl):","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"swirl = @fum function swirl(x, y)\n    r = sqrt(y*y + x*x)\n\n    v1 = x*cos(r*r) + y*sin(r*r)\n    v2 = x*sin(r*r) - y*cos(r*r)\n\n    y = v1\n    x = v2\n    return point(y,x)\nend","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Here, we are using the @fum syntax to show how users might define their own operators. The same can be done for colors.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"The code here does not change significantly, except that we create a H_post and add it to the fractal_flame(...) function:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"...\n    H_post = Hutchinson(swirl_operator)\n\n    layer = FableLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H = H, H_post = H_post,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n...","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"There are a few nuances to point out:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"We are using Shaders.previous, which simply means that the swirl will use whatever colors were specified in H.\nFable operators can be called with fee or Hutchinson and require Array or Tuple inputs.\nfinal = true, means that this is a post processing operation. In other words, H creates the object primitive (square), and H_post always operates on that square.\nWe are specifying the Floating Type, FloatType, as Float32, but that is not necessary.","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Once this is run, it should provide the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a swirled square)","category":"page"},{"location":"examples/swirled_square/#Step-3:-a-different-kind-of-swirl","page":"Rotating Square","title":"Step 3: a different kind of swirl","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"Now some people might be scratching their heads at the previous result. If we are solving with both H and H_post, why does it look like two separate actions instead of one combined one? In other words, why is the swirl so clearly different than the square operation?","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"This is because we operate on two separate sets of points. H creates object primitives. Every step of the simulation, we will read from the points after H operates on them. H_post works on a completely different location in memory specifically for image output. If we want, we can make H_post operate on the object, itself, by creating a new fractal executable:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"    final_H = fee(Hutchinson, [H, H_post])\n\n    layer = FableLayer(res; ArrayType = ArrayType, logscale = false,\n                         FloatType = FloatType, H = final_H\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"which will create the following image:","category":"page"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"(Image: a swirled square (again))","category":"page"},{"location":"examples/swirled_square/#The-full-example","page":"Rotating Square","title":"The full example","text":"","category":"section"},{"location":"examples/swirled_square/","page":"Rotating Square","title":"Rotating Square","text":"function square_example(num_particles, num_iterations;\n                        ArrayType = Array,\n                        dark = true,\n                        transform_type = :standard,\n                        filename = \"out.png\")\n    # Physical space location. \n    world_size = (9*0.15, 16*0.15)\n\n    # Pixels per unit space\n    # The aspect ratio is 16x9, so if we want 1920x1080, we can say we want...\n    ppu = 1920/world_size[2]\n\n    colors = [[1.0, 0.25, 0.25,1],\n              [0.25, 1.0, 0.25, 1],\n              [0.25, 0.25, 1.0, 1],\n              [1.0, 0.25, 1.0, 1]]\n\n    H = define_square(; position = [0.0, 0.0], rotation = pi/4,  color = colors)\n    swirl_operator = fo(Flames.swirl)\n    H_post = nothing\n    if transform_type == :outer_swirl\n        H_post = Hutchinson(swirl_operator)\n    elseif transform_type == :inner_swirl\n        H = fee(Hutchinson, [H, Hutchinson(swirl_operator)])\n    end\n\n    layer = FableLayer(; ArrayType = ArrayType, logscale = false,\n                         world_size = world_size, ppu = ppu,\n                         H = H, H_post = H_post,\n                         num_particles = num_particles,\n                         num_iterations = num_iterations)\n\n    run!(layer)\n\n    write_image(layer; filename = filename)\nend\n","category":"page"},{"location":"#What-is-Fable?","page":"General Information","title":"What is Fable?","text":"","category":"section"},{"location":"","page":"General Information","title":"General Information","text":"Fable is an animation engine that attempts to create a general-purpose rendering engine via Iterated Function Systems (IFSs).","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"The current Fable.jl API is still in active development, but for those wanting to learn about how to use it, there are several examples available to learn from. Though Fable.jl focuses on creating general-purpose animations with fractals, other rendering modes are either supported or planned to be implemented in the future. For now, the only available rendering modes are:","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"Hutchinson operators: These are used to describe Iterated Function Systems and are the primary focus of Fable.jl\nColors: This mode is somewhat trivial and will just create a layer of a specified color\nShaders: This mode leverages the framework used to describe IFSs to color an image with some user-provided equation.","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"We would like to support rendering via raytracing, raymarching, and rasterization in the future for those who wish to use such features. If you would like to learn how to use any of the existing rendering modes, please look at the layering section of our documentation.","category":"page"},{"location":"#What-are-Iterated-Function-Systems?","page":"General Information","title":"What are Iterated Function Systems?","text":"","category":"section"},{"location":"","page":"General Information","title":"General Information","text":"We plan to put more information in the docs, but there is a great article already describing them in the Algorithm Archive. For now, please go there for more information.","category":"page"},{"location":"#General-Fable.jl-workflow","page":"General Information","title":"General Fable.jl workflow","text":"","category":"section"},{"location":"","page":"General Information","title":"General Information","text":"Fable.jl is generally structured around building a Fable Executable (fee). In the case you want to use the fractal rendering mode, this fee will be a function system, so for a Sierpinski Triangle, it would look like this:","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"beginaligned\nf_1(PA) = fracP+A2 \nf_2(PB) = fracP+B2 \nf_3(PC) = fracP+C2\nendaligned","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"Here, P is some point location and A, B, and C are all vertices of the triangle. For Fable.jl, each function is called a Fable User Method (fum or FableUserMethod). If the user wants to change the variables dynamically, they might create a Fable Input (fi or FableInput). Finally, each function should have some sort of color (or shader) associated with it. Combining two fums for both the position and color functions creates a Fable Operator (fo or FableOperator) So, how do you use Fable.jl?","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"Well...","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"fee, the Fable Executable is the thing you are building\nfi, the Fable Input(s) are the variables needed for your executable\nfo, the Fable Operator is the function you are using in your executable, complete with probability and color or shader information\nfum, the Fable User Method is how users actually create colors and Fable Operators.","category":"page"},{"location":"","page":"General Information","title":"General Information","text":"I am intending to write more docs here, but check out the examples for more information on specifically how to use these.","category":"page"}]
}
