<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simple Smears · Fable.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Fable.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Fable.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">General Information</a></li><li><a class="tocitem" href="../../layering/">Layering</a></li><li><a class="tocitem" href="../../time_interface/">Time Interface</a></li><li><a class="tocitem" href="../../postprocessing/">Post Processing</a></li><li><a class="tocitem" href="../../research_directions/">Research Directions</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../swirled_square/">Rotating Square</a></li><li class="is-active"><a class="tocitem" href>Simple Smears</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Just-the-code"><span>Just the code</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Simple Smears</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simple Smears</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/leios/Fable.jl/blob/main/docs/src/examples/smear.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Simple-Smear"><a class="docs-heading-anchor" href="#A-Simple-Smear">A Simple Smear</a><a id="A-Simple-Smear-1"></a><a class="docs-heading-anchor-permalink" href="#A-Simple-Smear" title="Permalink"></a></h1><p>Animations are made by stitching together a series of images to give the illusion of motion. When creating an animation, we can choose the number of images we show to our viewers every second. Cinematic movies are typically shown at 24 frames per second (fps). Video games do not usually have a set fps value, but most people usually prefer 60 or higher. Youtube videos can be set to whatever you want, but I typically prefer either 30 or 60 depending on the situation.</p><p>Now here&#39;s a weird quirk of the human brain. Old-school animations are usually 24 fps, but seem incredibly smooth. If you play a video game at 24 fps, it can sometimes be nauseating.</p><p>Why?</p><p>Well, there is no hard answer to this, but video game engines are tasked at showing sometimes thousands of objects to you in real time. This is a really demanding process for your graphics card, so engines will do whatever they can to render things as quickly as possible while still being correct. Even worse for the game engine, it does not always know it&#39;s next frame because it has to take the actions of the player into account.</p><p>This is starkly contrasting the animation industry where it might take days to draw even a single frame. Because the entire movie has been drawn on a storyboard before-hand, the artists know what to draw and how to guide the viewer to the next important scene. After months of hard work, all the animators come together and coalesce their art into the final video.</p><p>So let&#39;s compare and contrast the difference between these two approaches. If a game engine is given 3 frames to move a circle from the upper left to lower right of the screen, it will render the circle at the start and end location along with the intermediary frames, like so:</p><table><tr><th style="text-align: right">Frame 1</th><th style="text-align: right">Intermediate Frame</th><th style="text-align: right">Final Frame</th></tr><tr><td style="text-align: right"><img src="../res/smear_1.png" alt="frame_1"/></td><td style="text-align: right"><img src="../res/nosmear_2.png" alt="frame_2"/></td><td style="text-align: right"><img src="../res/smear_3.png" alt="frame_3"/></td></tr></table><p>Animators will do things a little differently. The start and end will look the same, but the intermediary frame will be squashed to show the direction of motion:</p><table><tr><th style="text-align: right">Frame 1</th><th style="text-align: right">Intermediate Frame</th><th style="text-align: right">Final Frame</th></tr><tr><td style="text-align: right"><img src="../res/smear_1.png" alt="frame_1"/></td><td style="text-align: right"><img src="../res/smear_2.png" alt="frame_2"/></td><td style="text-align: right"><img src="../res/smear_3.png" alt="frame_3"/></td></tr></table><p>The intermediary frame is called a smear frame and this technique is used almost everywhere in modern animation. If you have ever seen a really smooth animation, it&#39;s probably because there were really good smears between different character positions. Smear frames are also why characters might look a little weird when you pause an animated video at the wrong place.</p><p>Simply put: if an animation lacks smear frames, it might start to look like a low fps video game. We want to avoid that as best as we can!</p><p>So, let&#39;s get to it!</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>To start, I will create a function that use the <code>num_particles</code>, and <code>num_iterations</code> for the naive chaos game kernel. Note in this case, I am also using <code>ArrayType</code> for the Array Type (<code>Array</code> for CPU or <code>CuArray</code> for GPU), and <code>num_frames</code> for the total number of frames. Finally, I will create an <code>output_type</code> variable that can be either <code>:video</code>, or <code>:image</code> to output to video (<code>out.mp4</code>) or images (<code>check*.png</code>):</p><pre><code class="nohighlight hljs">using Fable, CUDA, AMDGPU

function main(num_particles, num_iterations, total_frames; ArrayType = Array,
              output_type = :video)
</code></pre><p>Now I will define the image and video parameters:</p><pre><code class="nohighlight hljs">    # define image domain
    world_size = (9, 16)
    ppu = 1920 / 16
    res = (1080, 1920)
    layer = FractalLayer(; ArrayType = ArrayType,
                         world_size = world_size, ppu = ppu,
                         num_particles = num_particles,
                         num_iterations = num_iterations)

    # defining video parameters
    if output_type == :video
        video_out = open_video(res; framerate = 30, filename = &quot;out.mp4&quot;,
                               encoder_options = (crf=23, preset=&quot;medium&quot;))
    end
</code></pre><p>Note that the video will stitch together a series of frames, so we still need the pixels from <code>layer</code> hanging around. Now we define the ball:</p><pre><code class="nohighlight hljs">    # define ball parameters
    position = [-2.0, -2.0]
    ball = define_circle(; position = position,
                           radius = 1.0,
                           color = (1,1,1))</code></pre><p>And now we start getting ready for the smear frame transformation:</p><pre><code class="nohighlight hljs">    # fractal inputs to track changes in position, scale, and theta for smear 
    object_position = fi(&quot;object_position&quot;, position)
    scale = fi(&quot;scale&quot;, (1,1))
    theta = fi(&quot;theta&quot;, 0)

    # first defining the fractal user method
    smear = Smears.stretch_and_rotate(object_position = object_position,
                                      scale = scale, theta = theta)

    # now turning it into a fractal operator
    smear_transform = fee(Hutchinson, FractalOperator(smear))</code></pre><p>For this, we are creating fractal inputs (<code>object_position</code>, <code>scale</code>, and <code>theta</code>) for the <code>stretch_and_rotate</code> fractal user method. We then turn this into a fractal operator. Note that fractal inputs are good for when you need to update the value of certain parameters on the fly. For clarity, here is the <code>stretch_and_rotate</code> fractal user method:</p><pre><code class="nohighlight hljs">stretch_and_rotate = @fum function stretch_and_rotate(
    x,y;
    object_position = (0,0),
    scale = (1,1),
    theta = 0)

    y = (y - object_position[1])*scale[1]
    x = (x - object_position[2])*scale[2]

    temp_x = x*cos(theta) - y*sin(theta)
    temp_y = x*sin(theta) + y*cos(theta)

    x = temp_x + object_position[2]
    y = temp_y + object_position[1]
    return (y,x)
end</code></pre><p>After this, we need to attach the newly generated operators to the <code>FractalLayer</code>:</p><pre><code class="nohighlight hljs">    # attaching each operator to the layer
    layer.H1 = ball
    layer.H2 = smear_transform</code></pre><p>Finally, we have the animation loop:</p><pre><code class="nohighlight hljs">    for i = 1:total_frames

        # changing ball position
        radius = 1.0
        pos = [-2.0+4*(i-1)/(total_frames-1),
               -2.0+4*(i-1)/(total_frames-1)]

        # creating a value that grows as it gets closer to total_frames / 2
        # and shrinks as it gets closer to total_frames
        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)

        # modifying fractal inputs for smear
        set!(object_position, pos)
        set!(scale, (1,scale_x))
        set!(theta, pi/4)

        run!(layer)

        if output_type == :video
            write_video!(video_out, [layer])
        elseif output_type == :image
            filename = &quot;check&quot;*lpad(i,5,&quot;0&quot;)*&quot;.png&quot;
            write_image([layer], filename)
        end

        # clearing frame
        zero!(layer)
    end
</code></pre><p>This does 4 things:</p><ol><li>It updates the circle at every step.</li><li>It re<code>set</code>s the <code>object_position</code>, <code>scale</code>, and <code>theta</code> for the <code>smear_trasnform</code>.</li><li>It outputs to either video or image.</li><li>It sets the canvas values back to 0 for the next frame</li></ol><p>Once this is done, all we need to do is close the video (if we were outputting to video at all:</p><pre><code class="nohighlight hljs">    if (output_type == :video)
        close_video(video_out)
    end
</code></pre><p>If we run <code>main(10000, 10000, 10, CuArray; output_tupe = :video)</code>, we will get the following video:</p><p><video src="../res/smear.mp4" controls="true" title="smear_video"><a href="../res/smear.mp4">smear_video</a></video></p><h2 id="Just-the-code"><a class="docs-heading-anchor" href="#Just-the-code">Just the code</a><a id="Just-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Just-the-code" title="Permalink"></a></h2><p>And here is the full code:</p><pre><code class="nohighlight hljs">function smear_example(num_particles, num_iterations, total_frames;
                       ArrayType = Array, output_type = :video)
    FloatType = Float32

    # define image domain
    world_size = (9, 16)
    ppu = 1920 / 16
    res = (1080, 1920)
    layer = FractalLayer(; ArrayType = ArrayType, FloatType = FloatType,
                         world_size = world_size, ppu = ppu,
                         num_particles = num_particles,
                         num_iterations = num_iterations)

    # defining video parameters
    if output_type == :video
        video_out = open_video(res; framerate = 30, filename = &quot;out.mp4&quot;)
    end

    # define ball parameters
    object_position = fi(&quot;object_position&quot;, [-2.0, -2.0])
    ball = define_circle(; position = object_position,
                           radius = 1.0,
                           color = (1,1,1))

    # fractal inputs to track changes in position, scale, and theta for smear 
    scale = fi(&quot;scale&quot;, (1,1))
    theta = fi(&quot;theta&quot;, 0)

    # first defining the fractal user method
    smear = Smears.stretch_and_rotate(object_position = object_position,
                                      scale = scale, theta = theta)

    # now turning it into a fractal operator
    smear_transform = fee(Hutchinson, fo(smear))

    layer.H1 = ball
    layer.H2 = smear_transform

    for i = 1:total_frames

        # changing ball position
        radius = 1.0
        pos = [-2.0+4*(i-1)/(total_frames-1),
               -2.0+4*(i-1)/(total_frames-1)]

        # creating a value that grows as it gets closer to total_frames / 2
        # and shrinks as it gets closer to total_frames
        scale_x = 2 - abs((i-1)*2-(total_frames-1))/(total_frames-1)

        # modifying fractal inputs for smear
        set!(object_position, pos)
        set!(scale, (1,scale_x))
        set!(theta, pi/4)

        run!(layer)

        if output_type == :video
            write_video!(video_out, [layer])
        elseif output_type == :image
            filename = &quot;check&quot;*lpad(i,5,&quot;0&quot;)*&quot;.png&quot;
            write_image([layer]; filename=filename)
        end

        # clearing frame
        zero!(layer)
    end

    if (output_type == :video)
        close_video(video_out)
    end

end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../swirled_square/">« Rotating Square</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 18 May 2023 14:07">Thursday 18 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
